<html>

<head>
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<title>CNTService v1.80</title>
<link href="naughter.css" rel="stylesheet" type="text/css">
</head>

<body>

<h2 align="left"><img height="36" src="serv.gif" width="44">CNTService v1.80</h2>
<p>Welcome to <strong>CNTService</strong>, a collection of freeware C++ classes 
which provide a class framework for developing NT services in MFC. </p>
<p>For detailed information about NT services, how to develop them and their relationship 
to other NT subsystems, I would suggest you thoroughly read the relevant documentation 
which comes with the Windows SDK.</p>
<p>&nbsp;</p>
<table width="240">
	<tr>
		<td width="236"><a href="#Features">Features</a></td>
	</tr>
	<tr>
		<td width="236"><a href="#Usage">Usage</a></td>
	</tr>
	<tr>
		<td width="236"><a href="#Copyright">Copyright</a></td>
	</tr>
	<tr>
		<td width="236"><a href="#History">History</a></td>
	</tr>
	<tr>
		<td width="236"><a href="#APIReference">Class Framework Reference</a></td>
	</tr>
	<tr>
		<td width="236"><a href="#Enhancements">Planned Enhancements</a></td>
	</tr>
	<tr>
		<td width="236"><a href="#References">References</a></td>
	</tr>
	<tr>
		<td width="236"><a href="#Contact">Contacting the Author</a></td>
	</tr>
</table>
<p>&nbsp;</p>
<h2><a name="Features"></a>Features</h2>
<ul>
	<li>Simple and clean C++ interface using virtual functions.</li>
	<li>All the code is Unicode enabled and build configurations are provided.</li>
	<li>All code compiles cleanly at the highest warning level of 4. This is the 
	case with all of my other code on my web site as well.</li>
	<li>Built in persistence functions which provide support similar to the built 
	in MFC registry / ini functions.</li>
	<li>A simple test service has been provided to help you get started developing 
	your own NT services.</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><a name="Usage"></a>Usage</h2>
<ul>
	<li>Bear in mind that these classes are very NT specific and none of this code 
	will work correctly on Windows 9x. Windows 9x does provide some support for 
	services but in a completely incompatible manner with NT services.</li>
	<li>To use the classes in your code simple include ntserv*.cpp in your project 
	and #include ntserv.h in which ever of your modules needs to make calls to the 
	class and derive your own service class from CNTService and override the necessary 
	functions.</li>
	<li>You should also copy across the &quot;IDS_NTSERV...&quot; string resources from the 
	sample project into your service&#39;s project. You can use copy and paste in the 
	resource editor in Visual C++ 6.0 and later to achieve this. </li>
	<li>You can optionally also develop a simple DLL of the same name as your service 
	which includes just the MC resources. See the &quot;TestSrvMsg&quot; subproject in the 
	sample for how this works. For further information on this check on the history 
	details for v1.06 and v1.08 below.</li>
	<li>To see the class in action, have a look at the code in InitInstance in the 
	module &quot;app.cpp&quot;. </li>
	<li>Your code will need to include MFC either statically or dynamically.</li>
	<li>As of v1.76, the code is now for Visual C++ 2005 or later. I will not be 
	supporting VC 6 anymore for this code, so please don&#39;t email me requesting this&lt;gg&gt;. 
	Remember VC 6 is now a ten year old compiler. It&#39;s now time to upgrade to VC 
	2005 or VC 2008!</li>
	<li>As of v1.80, the code by default does not rely on MFC anymore. If you 
	still prefer MFC usage in the class framework then define the preprocessor 
	value &quot;CNTSERVICE_MFC_EXTENSIONS&quot;</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><a name="Copyright"></a>Copyright</h2>
<ul>
	<li>You are allowed to include the source code in any product (commercial, shareware, 
	freeware or otherwise) when your product is released in binary form.</li>
	<li>You are allowed to modify the source code in any way you want except you 
	cannot modify the copyright details at the top of each module.</li>
	<li>If you want to distribute source code with your application, then you are 
	only allowed to distribute versions released by the author. This is to maintain 
	a single distribution point for the source code.</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><a name="History"></a>History</h2>
<p><strong>V1.0 (17 July 1998)</strong> </p>
<ul>
	<li>Initial public release.</li>
</ul>
<p><strong>24 August 1998</strong> </p>
<ul>
	<li>Minor update to the demo program (app.cpp) to get rid of a compiler error.</li>
</ul>
<p><strong>V1.01 (17 May 1999)</strong> </p>
<ul>
	<li>Addition of a number of ASSERT&#39;s statements to aid in debugging. </li>
	<li>Fixed a bug in CNTEventLogSource::Report as reported by Marin Kunev</li>
	<li>Fixed a compiler warning when compiled with VC 6.</li>
</ul>
<p><strong>V1.02 (5 September 1999)</strong> </p>
<ul>
	<li>Addition of more ASSERT&#39;s statements to aid in debugging. </li>
</ul>
<p><strong>V1.03 (3 October 1999)</strong> </p>
<ul>
	<li>Addition of GetProfileStringArray, WriteProfileStringArray, GetProfileBinary 
	and WriteProfileBinary methods to the CNTService class.</li>
	<li>Renamed some module names.</li>
</ul>
<p><strong>V1.04 (5 October 1999)</strong> </p>
<ul>
	<li>Fixed a problem compiling the mc file for release and Unicode build configurations.</li>
	<li>Fixed a level 4 warning when built using VC++ 6.</li>
</ul>
<p><strong>V1.05 (10 October 1999)</strong> </p>
<ul>
	<li>Added support for the description field which services can have on Windows 
	2000.</li>
	<li>Added accessor functions for the service name, friendly name and the description 
	text.</li>
</ul>
<p><strong>V1.06 (24 January 2000)</strong> </p>
<ul>
	<li>Modified the way the mc file is included into the TestSrv.exe sample service. 
	The mc file is now compiled into an intermediate &quot;ntserv_msg.rc&quot; file which 
	is &quot;#included&quot; into the final rc file &quot;testsrv.rc&quot;. This is done so that the 
	&quot;testsrc.rc&quot; file can be edited by the resource designer inside Visual C++. 
	In previous versions of CNTService, if your tried to edit the rc file (which 
	was generated by the MC command line compiler), you would end up corrupting 
	the file. If you are developing your own service using CNTService, then I would 
	suggest you take this approach. What you need to do is create a resource script 
	inside VC++, adding whatever resources you want to be in your services resources 
	(e.g. version info&#39;s, strings etc), then bring up the resource includes dialog 
	and modify the &quot;Compile-Time directives&quot; to &quot;#include &quot;ntserv_msg.rc&quot; or your 
	version of rc file which was generated by MC by compiling your .mc file. You 
	should also check out the project settings in the demo service provided with 
	CNTService to see how it handles compilation of the .mc file via a batch file 
	(right mouse click on &quot;ntserv_msg.mc&quot; and select settings). </li>
</ul>
<p><strong>V1.07 (10 April 2000)</strong> </p>
<ul>
	<li>Fixed a bug with the calculation of buffer sizes when compiled for UNICODE 
	in CNTEventLogSource::SetStringArrayIntoRegistry</li>
</ul>
<p><strong>V1.1 (21 May 2000)</strong> </p>
<ul>
	<li>Added 2 new overridden versions of CNTEventLogSource::Report</li>
	<li>Tweaked and set default parameters in CNTService::ReportStatusToSCM following 
	review of the book &quot;Professional NT Services&quot;</li>
	<li>Disallowed accepting any controls when the service is currently processing 
	the same control in ReportStatusToSCM</li>
	<li>Change the ordering of parameters in ReportStatusToSCM. You should review 
	your code to ensure it is correct if you have existing code</li>
	<li>Class framework now by default uses a DLL of the same name for the message 
	file which the NT Event log will look to for mc string entries. This means that 
	you should review your code to ensure it is correct if you have existing code</li>
	<li>CNTEventLogSource::Report now does not bother automatically creating a SID 
	as this should be used for services which do impersonation for clients</li>
	<li>Changed the constructor of CNTEventLog which now takes the values it needs 
	for calling Register</li>
	<li>CNTEventLog::Report methods are now no longer const because of change above.</li>
	<li>SCM database is now locked during installs and uninstalls of the service</li>
	<li>Now supports all the new functionality provided for services under Windows 
	2000 while preserving binary compatibility with NT 3.x and NT 4 services.</li>
	<li>Framework now requires the presence of the January 2000 platform SDK or 
	later. This is because of point above.</li>
	<li>Changed the prototype of the existing CNTScmService::QueryStatus function.
	</li>
	<li>Made the typedefs for the enumeration functions private to their respective 
	classes instead of polluting the global name space</li>
</ul>
<p><strong>V1.11 (19 June 2000)</strong> </p>
<ul>
	<li>Added an ASSERT to ReportStatusToSCM for status handle == 0</li>
	<li>Fixed a number of other logic problems in ReportStatusToSCM</li>
	<li>Removed an unnecessary ASSERT in CNTEventLogSource::Report</li>
	<li>Sample service app now uses sound card default sound instead of PC speaker 
	sound</li>
</ul>
<p><strong>V1.12 (21 June 2000)</strong> </p>
<ul>
	<li>Minor change to a TRACE statement in RegisterCtrlHandler</li>
	<li>RegisterCtrlHandler is called automatically for you now, no need to call 
	it in your derived version of ServiceMain</li>
	<li>Added a BOOL CNTEventLogSource::Report(WORD wType, LPCTSTR lspszString) 
	method</li>
	<li>Fixed a bug where the sample service was not reporting its shutdown status 
	to the SCM correctly.</li>
</ul>
<p><strong>V1.13 (28 July 2000)</strong> </p>
<ul>
	<li>Fixed a project settings bug which was causing the following compiler error
	<i>&quot;fatal error C1083: Cannot open include file: &#39;ntserv_msg.h&#39;: No such file 
	or directory&quot;</i>. </li>
</ul>
<p><strong>V1.14 (21 December 2000)</strong> </p>
<ul>
	<li>Fixed a bug in CNTService::Uninstall() which was causing it to fail sometimes 
	when the service was running.</li>
	<li>Made all the member variables of the CNTService class public but put them 
	down below the &quot;implementation&quot; line ala the way standard MFC classes are declared.</li>
	<li>Added a new overridden version of CNTEventLogSource::Report.</li>
</ul>
<p><strong>V1.15 (8 January 2001)</strong> </p>
<ul>
	<li>Now includes copyright message in the source code and documentation.</li>
	<li>CNTEventLogSource::Report now allows you to specify whether error codes 
	should be displayed in Hex or as decimal</li>
	<li>Sample service sometimes did not display the stop event. This has been remedied 
	by reporting to the event log before we report to the SCM.</li>
	<li>Framework has now been made independent of the need for the latest Platform 
	SDK header files. You can now compile the code in VC 5 without the Platform 
	SDK having to be installed.</li>
</ul>
<p><strong>V1.16 (16 May 2001)</strong> </p>
<ul>
	<li>Thread protected code to CNTEventLogSource::Report.</li>
</ul>
<p><strong>V1.17 (27 May 2001)</strong> </p>
<ul>
	<li>Added methods to framework to support the new command line options -start, 
	-pause, -continue and -stop. Thanks to Stefan Niemeyer for this great addition.</li>
	<li>Fixed a small issue in the testing of the CEventLogSource class in app.cpp.</li>
</ul>
<p><strong>V1.18 (15 July 2001)</strong> </p>
<ul>
	<li>Fixed a problem when calling CreateService with pathnames which contain 
	embedded spaces.</li>
</ul>
<p><strong>V1.19 (18 July 2001)</strong> </p>
<ul>
	<li>Minor update to the sample code demonstrating the class framework.</li>
	<li>Due to VC 6 shipping with a Winsvc.h (The main NT service header file) which 
	includes some but not all of the defines which the class requires you need to 
	define a few preprocessor define to get the code to compile cleanly for your 
	particular setup. Set the top of &quot;ntserv.cpp&quot; for the details.</li>
</ul>
<p><strong>V1.20 (9 August 2001)</strong> </p>
<ul>
	<li>Updated SetStringArrayIntoRegistry and GetStringArrayIntoRegistry to be 
	consistent with my other class CHKLM v1.11.</li>
</ul>
<p><b>v1.21 (27 November 2001)</b></p>
<ul>
	<li>Fixed an issue where the class fails to read any key that is read-only. 
	This is a problem since Win2000 defaults access to HKLM for &quot;normal&quot;&nbsp; users 
	to read-only. Thanks to Hans-Georg Ulrich for spotting this problem.</li>
</ul>
<p><b>v1.22 (27 August 2002)</b></p>
<ul>
	<li>Made more functions virtual to allow greater end user customisation.</li>
	<li>All useful attributes in call to CreateService in CNTService::Install can 
	now be modified without having to derive a custom version of CNTService::Install 
	in your derived class.</li>
	<li>A boolean value is now provided to enable / disable event log integration</li>
</ul>
<p><b>v1.23 (28 August 2002)</b></p>
<ul>
	<li>Reviewed all TRACE statements in the code for correctness</li>
	<li>Added a parameter to CNTService::Install to allow the time to wait for the 
	service to stop to be specified</li>
	<li>Added a CString parameter to the CNTService::Install and Uninstall methods 
	to return a descriptive errors to callers.</li>
	<li>Addition of a new boolean variable to the CNTService class&nbsp; to allow 
	service to decide whether it should use GUI or Console calls to display status 
	messages</li>
	<li>CNTService::ProcessShellCommand now displays error messages to the console 
	or via a Message box when errors occur in install, uninstalling, starting, stopping, 
	resuming and pausing the service.</li>
</ul>
<p><b>v1.24 (20 September 2002)</b></p>
<ul>
	<li>Fixed an &quot;issue&quot; in calls to ReportStatusToSCM which your service should 
	be calling in your ServiceMain. Specifically calling ReportStatusToSCM(SERVICE_STOPPED) 
	looks like it elicits the behaviour that the SCM forcefully terminates your 
	worker thread. This can cause issues when other code is executed after this 
	call which uses something which is allocated on the worker threads stack. To 
	fix this &quot;issue&quot; (I could not find any documentation on this behaviour) you 
	should remove the single call to ReportStatusToSCM which uses the values &quot;SERVICE_STOPPED&quot; 
	from the bottom of your service&#39;s ServiceMain function. To force you to do this, 
	I have changed the name of the function &quot;ReportStatusToSCM&quot; to just &quot;ReportStatus&quot;. 
	This will mean that the compiler will force you to examine each call to this 
	function and remove the one call as described above. The class framework now 
	looks after reporting that your service has stopped to the SCM. Thanks to &quot;Jim&quot; 
	for spotting this.</li>
</ul>
<p><b>v1.25 (20 November 2002)</b></p>
<ul>
	<li>Fixed 3 level 4 warnings when the code is compiled using VC.Net. Thanks 
	to Ed Eichman for spotting this problem.</li>
</ul>
<p><b>v1.26 (12 March 2003)</b></p>
<ul>
	<li>Fixed a problem since user code can&#39;t call ReportStatus(SERVICE_STOPPED) 
	there is no way to report start-up or shutdown errors via dwWin32ExitCode or 
	dwServiceSpecificExitCode. This has been resolved by adding a new protected 
	function TerminateService to shut down the service in the event of a critical 
	failure. This throws a private exception containing the exit codes which is 
	caught by the framework in _ServiceMain (or the DebugService case of ProcessShellCommand). 
	_ServiceMain then passes the codes on via _ReportStatus. Also since the dwWin32ExitCode 
	and dwServiceSpecificExitCode arguments of ReportStatus can never be used these 
	parameters have now been removed. Thanks to Jon Baggott for these 2 additions.</li>
	<li>Performed some minor tidy ups in the inclusion of header files by the framework</li>
</ul>
<p><b>v1.27 (8 May 2003)</b></p>
<ul>
	<li>Update to the Install and Uninstall methods to return the value from GetLastError(). 
	This is useful for client code as it can be reset before the functions return.</li>
	<li>Command line now supports a /T: param which allows you to specify a timeout 
	to use when doing an uninstall. This timeout is used to specify how long the 
	code will wait if the service needs to be stopped.</li>
	<li>Broke down all the classes into their own modules. This allows you to pull 
	in only the classes you require, if you are not using the main class CNTService.</li>
	<li>Removed all unnecessary TRACE statements throughout the framework as they 
	sometimes reset the value as returned from GetLastError.</li>
</ul>
<p><b>v1.28 (17 May 2003)</b></p>
<ul>
	<li>Further tweaks to _ReportStatus to avoid intermittent crashes. See item 
	1 on 20-09-2002 for detailed info about the issue.</li>
	<li>Removed some unnecessary calls to locking the critical section</li>
</ul>
<p><b>v1.29 (22 May 2003)</b></p>
<ul>
	<li>Updated the way the sample service&#39;s message dll projects integrates the 
	creation of the mc file. For detailed information on how to integrate mc files 
	into Visual Studio, please see the CodeProject article
	<a href="http://www.codeproject.com/useritems/MCTutorial.asp">http://www.codeproject.com/useritems/MCTutorial.asp</a>. 
	Please note that I did not follow the suggested settings as exactly outlined 
	in this article as the message file&#39;s header file needs to be included into 
	the NT service exe at compile time.</li>
</ul>
<p><b>v1.30 (3 August 2003)</b></p>
<ul>
	<li>Improved the error handling and reporting in CNTService::SetServiceToStatus. 
	Thanks to Jon Pawley for reporting this issue.</li>
</ul>
<p><b>v1.31 (15 August 2003)</b></p>
<ul>
	<li>Optimized the string copying in CEventLogRecord::CEventLogRecord(const EVENTLOGRECORD* 
	pRecord). A bug was reported in this area by Jeroen Walter but it looks like 
	this is a documentation bug in current versions of the MSDN. This structure 
	was defined correctly in some early versions of the MSDN.</li>
</ul>
<p><b>v1.32 (8 September 2003)</b></p>
<ul>
	<li>Moved all the defines which the framework requires into a separate header 
	file. Thanks to Dima Polyakov for pointing out a compilation problem which occurred 
	when you did not have the platform SDK installed which necessitated this change.</li>
	<li>Changed the ordering of the command line used to compile the MC file. This 
	avoids a problem as reported by Rodrigo Oliveira Fernandez when using the framework 
	in VC 7</li>
	<li>Fixed a compilation error related to the use of the preprocessor define 
	NTSERV_EXCLUDE_VC6_WINSVC_DEFINES</li>
</ul>
<p><b>v1.33 (4 October 2003)</b></p>
<ul>
	<li>Updated the custom build steps to compile the mc file. Now uses the VC macro 
	&quot;$(InputPath)&quot; instead of &quot;$(InputDir)\$(InputName).mc&quot;.</li>
	<li>Removed a number of unreferenced variables level 4 warnings when compiled 
	with VC.Net 2003.</li>
	<li>Provision of a specific workspace (Testsrv for Visual Studio.Net.dsw) which 
	allows the sample service to be compiled cleanly out of the box with Visual 
	Studio.Net 2000 or Visual Studio.Net 2003. The issue is that the format of various 
	build macros such as $(InputDir) has changed from VC 6. Just select File -&gt; 
	Open Project in VS.Net and select &quot;Testsrv for Visual Studio.Net.dsw&quot;.</li>
</ul>
<p><b>v1.34 (5 October 2003)</b></p>
<ul>
	<li>Updated the Visual Studio.Net workspace to remove the &quot;Without Platform 
	SDK&quot; configurations as they are not applicable.</li>
</ul>
<p><b>v1.35 (12 November 2003)</b></p>
<ul>
	<li>Now includes a unicode MC file thanks to Brodie Thiesfield. To use this 
	file, simply copy ntserv_msgU.mc over the ntserv_msg.mc file in the TestSrvMsg 
	and modify the custom build step for the mc file in the TestSrvMsg project to 
	include a -u command line option. This file also includes a Japanese translation 
	of the default service event log strings which the sample service uses.</li>
</ul>
<p><b>v1.36 (14 November 2003)</b></p>
<ul>
	<li>The location where the message dll for the service is located can now be 
	tweaked at runtime by filling in the CNTService::m_sMessageDll variable. Thanks 
	to Brodie Thiesfield for this update.</li>
	<li>Reviewed all TRACE statements which use a CString parameter. Now explicitly 
	casts the CString to a LPCTSTR. Thanks to Brodie Thiesfield for this update.</li>
	<li>Added a new CNTService::m_LoggingDetail variable. This in combination with 
	a new method called CNTService::Win32ErrorToString allows more flexible control 
	over how errors are logging to the event log. Thanks to Brodie Thiesfield for 
	suggesting this update.</li>
	<li>command line arguments other than the &quot;-debug&quot; argument are passed through 
	to ServiceMain() when running in debug mode. Thanks to Brodie Thiesfield for 
	suggesting this update.</li>
</ul>
<p><b>v1.37 (19 November 2003)</b></p>
<ul>
	<li>Reworked the function Win32ErrorToString to include the string resource 
	ID. Thanks to Brodie Thiesfield for suggesting this. </li>
	<li>Fixed CNTS_MSG_SERVICE_FAIL_PAUSE, CNTS_MSG_SERVICE_FAIL_CONTINUE and CNTS_MSG_SERVICE_FAIL_STOP 
	event log entries which were not using the new Win32ErrorToString method. Thanks 
	to Brodie Thiesfield for reporting this.</li>
	<li>Win32ErrorToString now includes a &quot;bEventLog&quot; parameter. When this is TRUE 
	the function is being called to obtain the error which gets displayed in the 
	event log, when FALSE, it is being used to display to the end user or the TRACE 
	window</li>
</ul>
<p><b>v1.38 (23 November 2003)</b></p>
<ul>
	<li>Fixed a memory leak in CNTService::Debug when the service uses TerminateService 
	to shutdown the service prematurely.</li>
</ul>
<p><b>v1.39 (26 November 2003)</b></p>
<ul>
	<li>Now supports a /silent command line option. Using this setting in combination 
	with for example /install will ensure that the framework does not display any 
	message boxes or console output when an error occurs. Thanks to Metrich Frederic 
	for this addition.</li>
	<li>Changed the return value from ProcessShellCommand from a BOOL to a DWORD. 
	This value is now use to return an error code from the service exe when it exits. 
	In combination with the /silent command line option, this allows third party 
	programs such as installers control over the service instance via the exit code 
	of the service. Again thanks to Metrich Frederic for this addition.</li>
	<li>Updated the sample app provided with the framework to show how client services 
	can return the Win32 error code as now returned by ProcessShellCommand.</li>
</ul>
<p><b>13 January 2004</b></p>
<ul>
	<li>Updated the declaration of the sample service&#39;s &quot;m_bWantStop&quot; variable to 
	now be a variable. There is no change to the actual CNTService modules (bar 
	copyright updates for the new year 2004) </li>
</ul>
<p><b>v1.40 (22 January 2004)</b></p>
<ul>
	<li>Fixed a bug in CNTScmService::EnumDependents and CNTServiceControlManager::EnumServices 
	where enumeration would continue even when the callback functions return FALSE. 
	Thanks to Edward Livingston for spotting this.</li>
</ul>
<p><b>21 February 2004</b></p>
<ul>
	<li>The Unicode version of the mc file has now been updated to include Korean 
	resources. Thanks to Brodie Thiesfield for this update.</li>
</ul>
<p><b>v1.41 (18 March 2004)</b></p>
<ul>
	<li>Fixed a bug in the CNTScmService::WaitForServiceStatus function which caused 
	it to return TRUE even if the service failed to return the desired status (if 
	pending status isn&#39;t the expected pending staus. </li>
	<li>Also ensured that CNTScmService::WaitForServiceStatus does not wait past 
	the requested timeout period. Thanks to Brodie Thiesfield for these bug reports 
	and the fixes.</li>
</ul>
<p><b>v1.42 (9 April 2004)</b></p>
<ul>
	<li>Further work to CNTScmService::WaitForServiceStatus. It now ignores pending 
	states. In addition it ignores wait hints since we are calling QueryServiceStatus 
	as opposed to calling the ControlService function with the SERVICE_CONTROL_INTERROGATE 
	control code. It also allows the polling interval to be specified by a 3rd optional 
	parameter. Thanks to Edward Livingston and &quot;yong&quot; for reporting this problem. 
	Please note that since the third parameter to this function means something 
	different that previously, you should review all of your calls to WaitForServiceStatus 
	to ensure it continues to operate correctly.</li>
</ul>
<p><b>v1.43 (12 April 2004)</b></p>
<ul>
	<li>Removed an unused variable in CNTScmService::WaitForServiceStatus. Thanks 
	to Edward Livingston for reporting this issue.</li>
</ul>
<p><b>v1.44 (5 May 2004)</b></p>
<ul>
	<li>Fixed some warnings in CNTService::GetDependencies and CNTEventLogSource::SetStringArrayIntoRegistry 
	when the code is compiled using the &quot;Force conformance in For loop scope&quot; VC 
	compiler option (/Zc:forScope). Thanks to Alexey Kuznetsov for reporting this 
	problem.</li>
</ul>
<p><b>v1.45 (20 June 2004)</b></p>
<ul>
	<li>Fixed a bug in CEventLogRecord::CEventLogRecord(const EVENTLOGRECORD*..) 
	to do with the handling of inter string NULLs at the end of the record. Thanks 
	to &quot;yong&quot; for reporting this problem.</li>
	<li>Optimized the code in CEventLogRecord::CEventLogRecord(const EVENTLOGRECORD*..).</li>
</ul>
<p><b>v1.46 (20 June 2004)</b></p>
<ul>
	<li>Provided a new virtual implementation of CNTService::_ServiceMain. To achieve 
	this the previous static _ServiceMain is now called &quot;_SDKServiceMain&quot;. This 
	allows your service code to completely customize the startup of your service. 
	For example if you service does not require an active worker thread to do any 
	work (e.g. it only ever responds to client requests thro the SCM using OnUserDefinedRequest), 
	then you could implement your own version of _ServiceMain which does not call 
	_ReportStatus(SERVICE_STOPPED... This would allow you to use RegisterWaitForSingleObject 
	to implement your service clean up code. For more information on this type of 
	service please consult the MSDN documentation on &quot;RegisterWaitForSingleObject&quot; 
	and &quot;ServiceMain&quot;. Thanks to Haug Leuschner for reporting this.</li>
</ul>
<p><b>v1.47 (24 June 2004)</b></p>
<ul>
	<li>Reissue of the last update as I forgot to declare _ServiceMain virtual, 
	Doh!</li>
	<li>Also made the class CNTServiceTerminateException visible in the global namespace. 
	This is required if you implement your own _ServiceMain.</li>
</ul>
<p><b>v1.48 (15 October 2004)</b></p>
<ul>
	<li>Framework now automatically installs a console ctrl handler when run in 
	debug mode. This means that the framework will automatically call your service&#39;s 
	OnStop method when running in debug mode if your service is built as a console 
	app and you hit Ctrl+C or Ctrl+Break or hit the close button in the console 
	window. This helps you to verify the shutdown code of your service without having 
	to run the code as a service. Because the console ctrl handler is executed in 
	a separate thread to ServiceMain, this simulation mode calls your OnStop method 
	in a separate thread just like the SCM does. This proves very helpful when you 
	need to debug shutdown problems in your service which are thread related.</li>
	<li>Added a few checks to various header files to warn if various header files 
	have not already been included e.g. Afxmt.h. This helps avoid simple compilation 
	problems when the framework is added to a new project initially.</li>
	<li>Sample app now uses the InterlockedExchange functions instead of a critical 
	section to serialize access to variables used across multiple threads. In addition 
	the &quot;m_bPaused&quot; variable of the sample app is now also marked as volatile</li>
	<li>Fixed a double declaration of &quot;dwTypesSupported&quot; in CNTEventLogSource::Install. 
	In the process this fixes a level 4 warning which the code generated.</li>
</ul>
<p><b>v1.49 (18 October 2004)</b></p>
<ul>
	<li>Fixed a number of level 4 warnings in the framework when &quot;Detect 64 bit 
	portability issues&quot; is enabled in Visual Studio .Net</li>
</ul>
<p><b>v1.50 (11 November 2004)</b></p>
<ul>
	<li>Fixed a futher 64 bit issue in CNTEventLogSource::SetStringArrayIntoRegistry 
	when compiled in Visual Studio .Net. </li>
	<li>Addition of a CNTSERVICE_EXT_CLASS preprocessor macro which allows the classes 
	to be easily added to an extension dll</li>
</ul>
<p><b>v1.51 (11 February 2005)</b></p>
<ul>
	<li>Addition of a virtual GetEventLogSourceName method which allows the name 
	of the event log source to be customized at runtime. Thanks to Bara Cek for 
	requesting this addition.</li>
	<li>Updated the copyright details in all modules.</li>
	<li>Addition of true Visual Studio .NET 2003 files for the sample service (Testsrv.sln 
	and Testsrv.vcproj)</li>
</ul>
<p><b>v1.52 (26 March 2005)</b></p>
<ul>
	<li>Addition of a m_bProfileWriteFlush variable to the CNTService class which 
	dictates if the registry settings should be committed immediately as opposed 
	to relying on the lazy writer.</li>
</ul>
<p><b>v1.53 (21 April 2005)</b></p>
<ul>
	<li>CNTService::GetProfileInt and GetProfileString functions now includes an 
	optional DWORD output parameter which when provided allows the value from GetLastError 
	to be returned to client code. This allows code to distinguish between a default 
	value which is returned because it is actually stored as opposed to returning 
	a default value because some of the registry API&#39;s failed. Thanks to Tony Ronan 
	for reporting this issue.</li>
</ul>
<p><b>v1.54 (31 July 2005)</b></p>
<ul>
	<li>Provided an overridden version of CNTEventLogSource::Report which has 3 
	string parameters</li>
	<li>CNTEventLogSource::GetStringArrayFromRegistry and SetStringArrayIntoRegistry 
	methods are now public as they are helpful to have available externally.</li>
</ul>
<p><b>v1.55 (14 August 2005)</b></p>
<ul>
	<li>Fixed an issue where the SID and binary values was not being set correctly 
	in the overloaded CEventLogRecord constructor which takes a EVENTLOGRECORD pointer. 
	Thanks to Brian Lee for reporting this issue. Also the arrays which this information 
	is copied into is now preallocated to improve performance.</li>
</ul>
<p><b>v1.56 (11 January 2006)</b></p>
<ul>
	<li>The command line options which the service uses to start with can now be 
	specified via a new /SCL command line option e.g. TestSrv.exe /install &quot;/SCL:/Param1 
	/SomeOtherParam:XYZ&quot;. This additional flexibility is controlled by BOOL CNTService::m_bAllowCommandLine 
	which by default is FALSE.</li>
	<li>Updated copyright details for all modules</li>
	<li>The service display name string which the service uses for installing can 
	now be specified via a new /SDN command line option. This is achieved by supporting 
	a new command line option e.g. TestSrv.exe /install &quot;/SDN:PJ&#39;s Second Test Service&quot;. 
	This additional flexibility is controlled by BOOL CNTService::m_bAllowDisplayNameChange 
	which by default is FALSE. </li>
	<li>The description string which the service uses for installing can now be 
	specified via a new /SD command line option. This is achieved by supporting 
	a new command line option e.g. TestSrv.exe /install &quot;/SD:Some description&quot;. 
	This additional flexibility is controlled by BOOL CNTService::m_bAllowDescriptionChange 
	which by default is FALSE.</li>
	<li>The service name string which the service uses for installing can now be 
	specified via a new /SN command line option. This is achieved by supporting 
	a new command line option e.g. TestSrv.exe /install &quot;/SN:PJSERVICE2&quot;. This additional 
	flexibility is controlled by BOOL CNTService::m_bAllowNameChange which by default 
	is FALSE.</li>
	<li>Removed code which writes an event log entry when the service is being uninstalling. 
	There is not much sense in logging an entry that you have uninstalled the service, 
	when you are also uninstalling the event log source.</li>
	<li>Removed the ANSI mc file. Instead now the mc file included in the zip file 
	is the Unicode mc file as provided by Brodie Thiesfield (see the history list 
	for v1.35).</li>
	<li>Updated the documentation to use the same style as the web site.</li>
	<li>When registering the service, the quoting of the path name to use for the 
	service is now done in CNTService::ProcessShellCommand instead of CNTScmService::Create.</li>
	<li>Optimized code in CNTServiceCommandLineInfo::CNTServiceCommandLineInfo.</li>
	<li>Removed unnecessary CNTServiceCommandLineInfo destructor.</li>
	<li>Removal of CNTService::GetEventLogSourceName method. Instead now you can 
	call m_EventLogSource.SetSourceName() to customize this value.</li>
	<li>Provision of CNTService::SetUseConsole and CNTService::GetUseConsole methods.</li>
	<li>The default setting for CNTService::m_bUseConsole is now set depending on 
	whether the standard _CONSOLE preprocessor define is declared</li>
	<li>Removed the unnecessary critical section lock in the CNTService constructor</li>
	<li>Provision of CNTService::SetControlsAccepted and CNTService::GetControlsAccepted 
	methods.</li>
	<li>Provision of a default CNTService constructor</li>
	<li>Addition of a default constructor for CNTEventLogSource </li>
	<li>Addition of CNTEventLogSource::SetServerName, CNTEventLogSource::GetServerName, 
	CNTEventLogSource::SetSourceName and CNTEventLogSource::GetSourceName methods</li>
	<li>Provision of CNTService::SetServiceName, CNTService::SetInstanceServiceName, 
	CNTService::SetMasterServiceName, CNTService::GetInstanceServiceName, CNTService::GetMasterServiceName, 
	CNTService::SetDisplayName, CNTService::SetMasterDisplayName, CNTService::SetInstanceDisplayName, 
	CNTService::GetMasterDisplayName, CNTService::GetInstanceDisplayName, CNTService::SetDescription, 
	CNTService::SetMasterDescription, CNTService::SetInstanceDescription methods, 
	CNTService::GetMasterDescription and CNTService::GetInstanceDescription. Most 
	of the work for this release of the framework is to support a new concept of 
	&quot;instances&quot; in CNTService. Prior to this version of the CNTService framework, 
	you could only ever install a single copy of any one service on the one machine. 
	Now with the introduction of the /SDN, /SD and /SN command line options which 
	are used during install and uninstall you can register the service multiple 
	times, using different service names, display names and descriptions. The original 
	values you construct your CNTService instance are called the master values and 
	are unmodified during the lifetime of all instances of your services. The &quot;instance&quot; 
	values are modifiable (if you allow them to be so via CNTService::m_bAllowNameChange, 
	CNTService::m_bAllowDisplayNameChange and CNTService::m_bAllowDescriptionChange) 
	at runtime. When these values are provided on the command line during registration, 
	the command line which the service is setup to use upon launch by the SCM is 
	customized so that these same command line options are passed to it. This allows 
	the same instance values to be available to the service when it is running as 
	a service. Without this neat trick, there would be no easy way for the service 
	to detect under which instance details it should run.</li>
	<li>Addition of 2 new command line options namely &quot;/App&quot; or &quot;/Application&quot;. 
	These behave the same way as the existing &quot;/Debug&quot; command line option.</li>
	<li>Addition of a DWORD* parameter to the CNTEventLogSource::GetStringArrayFromRegistry 
	and CNTEventLogSource::SetStringArrayFromRegistry functions. This allow the 
	details of the last error to be returned to client code.</li>
	<li>Addition of generic versions of CNTService::WriteProfileString, CNTService::WriteProfileInt, 
	CNTService::WriteProfileStringArray, CNTService::WriteProfileBinary, CNTService::GetProfileString, 
	CNTService::GetProfileInt, CNTService::GetProfileStringArray and CNTService::GetProfileBinary. 
	These implementations allow the service name to be specified as well as the 
	Flushing setting which is hidden by the other implementations. The existing 
	implementations of these functions now simply call these new implementations. 
	Providing these implementations now allows client code to read and write the 
	settings for any service (including other instances of the same service) without 
	the need to create a new CNTService instance.</li>
	<li>CNTServiceControlManager::EnumServices method now uses a void* parameter 
	for its item data instead of a DWORD.</li>
	<li>Addition of a CNTService::EnumerateInstances method which allows you to 
	enumerate all the instances of a service which have been installed using the 
	new master / instance additions to the framework in this version. This could 
	prove useful where you are writing configuration type applets which configure 
	the settings for all the instances of your installed service.</li>
	<li>Addition of a new /U command line option which allows the user account which 
	the service runs under to be configured.</li>
	<li>Addition of a new /P command line option which allows the password which 
	the service is to run with to be configured.</li>
	<li>As a security precaution once the username and password strings have been 
	used for installing, they are overwritten in memory.</li>
</ul>
<p><b>v1.57 (13 January 2006)</b></p>
<ul>
	<li>Addition of a new /AUTO command line option which allows you to specify 
	that the service should be started automatically.</li>
</ul>
<p><b>v1.58 (27 April 2006)</b></p>
<ul>
	<li>Code now uses SecureZeroMemory when wiping out the username and password 
	strings. This should further improve the security of these values when they 
	are manipulated by the class framework.</li>
</ul>
<p><b>v1.59 (12 May 2006)</b></p>
<ul>
	<li>Minor update to ntservEventLogRecord.cpp module to remove now unnecessary 
	include of AfxPriv.h. Thanks to Martin Richter for reporting this issue.</li>
	<li>Also updated the usage instructions in this document to describe how you 
	can use copy &amp; paste to speed up the job. Again thanks to Martin Richter for 
	reporting this issue.</li>
</ul>
<p><b>v1.60 (18 May 2006)</b></p>
<ul>
	<li>Minor update to rename the local variable of type _NTSERV_SERVICCONTROLMANAGER_DATA 
	which is used to hold function pointers. Thanks to Frederic Metrich for reporting 
	this issue.</li>
	<li>Minor update to rename the local variable of type _NTSERV_SCMSERVICE_DATA 
	which is used to hold function pointers. Thanks to Frederic Metrich for reporting 
	this issue.</li>
</ul>
<p><b>v1.61 (31 May 2006)</b></p>
<ul>
	<li>Updated the code to work correctly in VC 6 without the Platform SDK being 
	installed. I personally have the Feb 2003 Platform SDK installed with VC 6 and 
	this is how most of my code is primarily tested. It seems some of my recent 
	updates to CNTService have broken compatibility with VC 6 on its own. Also renamed 
	the define &quot;NTSERV_DO_NEW_WINSVC_DEFINES&quot; which is required when you are compiling 
	the class framework on Visual C++ 6 without the Platform SDK to be &quot;CNTSERVICE_MISSING_PLATFORMSDK&quot;. 
	Please note that I would advise all developers to install the Platform SDK (February 
	2003 was the latest version which was compatible with VC 6), as I will probably 
	drop support for VC 6 without the Platform SDK for CNTService in the future. 
	It is becoming too much work to support the older Header files which were shipped 
	with VC 6 and most of my other open source code is moving towards requiring 
	the Platform SDK. Thanks to Matthias Miller for reporting this issue. The &quot;NTSERV_EXCLUDE_VC6_WINSVC_DEFINES&quot; 
	define is now defunct and no longer used by the CNTService code.</li>
</ul>
<p><b>v1.62 (3 June 2006)</b></p>
<ul>
	<li>If CNTEventLogSource::Uninstall fails to remove the HKLM\System\CurrentControlSet\Services\EventLog\&quot;Display 
	Name&quot; registry key, then it aborts before doing any other work. Thanks to Matthias 
	Miller for reporting this issue.</li>
	<li>Fixed a minor typo in CNTService::SetServiceToStatus. Thanks to Matthias 
	Miller for reporting this issue.</li>
</ul>
<p><b>v1.63 (7 June 2006)</b></p>
<ul>
	<li>Removed three unreferrenced variables from CNTService::ProcessShellCommand. 
	Thanks to Frederic Metrich for reporting this issue.</li>
	<li>Minor update to the declaration of some functions in CNTService to using 
	&quot;WINAPI&quot; in their function implementations. Thanks to Frederic Metrich for reporting 
	this issue.</li>
	<li>Updated the code in CNTService::Debug to exclude the &quot;/debug&quot;, &quot;-app&quot;, &quot;/app&quot;, 
	&quot;-application&quot; and &quot;/application&quot; command line options in addition to the &quot;-debug&quot; 
	value. Again thanks to Frederic Metrich for reporting this issue.</li>
	<li>Updated the sample service provided with the CNTService download to build 
	as a console app instead of a Windows app. This allows you to check out the 
	console handler support which CNTService includes.</li>
</ul>
<p><b>v1.64 (9 June 2006)</b></p>
<ul>
	<li>Made CNTService::Initialize non virtual. This change was made because it 
	is called by the CNTService constructor and you cannot call virtual functions 
	from a C++ class constructor (or destructor). For more info on this issue please 
	see the online article at
	<a href="http://www.artima.com/cppsource/nevercall.html">http://www.artima.com/cppsource/nevercall.html</a> 
	from the book &quot;Effective C++&quot; by Scott Meyers. Thanks to Frederic Metrich for 
	spotting this issue. Because of this change you should examine your own code 
	which uses CNTService::Initialize to make sure this change has no side effects 
	on your code. </li>
</ul>
<p><b>v1.65 (13 June 2006)</b></p>
<ul>
	<li>Addition of a logname parameter to the CNTEventLogSource constructor to 
	support user defined event logs instead of logging to the standard &quot;Application&quot; 
	event log. Please note that the code added only enables the CNTService framework 
	to use non &quot;Application&quot; event logs, but it does not contain code to create 
	a custom event log. You will need to handle that in your application&#39;s install. 
	Thanks to Jan Bartels for this addition.</li>
	<li>Also optimized the construction of member variables in the CNTEventLogSource 
	constructors</li>
	<li>To allow customization in client projects, the resource id and message id 
	values can now be customized through two new virtual functions, namely CNTService::MapResourceID 
	and CNTService::MapMessageID. Thanks to Jan Bartels for this update.</li>
	<li>CNTService::SetServiceToStatus now exposes the interval to wait as a parameter 
	as well as the polling interval as a parameter. In addition the command line 
	timeout interval is now passed to all calls to SetServiceToStatus in CNTService::ProcessShellCommand. 
	The additional command line operations which are passed the timeout value include 
	starting, stopping, pausing and continuing the service, in addition to uninstalling 
	the service which when it was introduced in v1.27 was the only operation which 
	got the timeout value.</li>
	<li>Fixed a bug introduced in v1.64 where the sample service was updated to 
	run as a console app. What I forgot to do when making this change was put in 
	the call to AfxWinInit.</li>
</ul>
<p><b>v1.66 (24 June 2006)</b></p>
<ul>
	<li>Added a missing MapResourceID call in CNTService::Win32ErrorToString.
	</li>
	<li>Updated the sample dsp and vcproj files to produce Unicode mc resources 
	instead of ASCII.</li>
	<li>Framework now accepts the command line /console to mean the same as /debug 
	i.e. run the program as a normal (console) application without interacting with 
	the Service Control Manager.</li>
	<li>Updated code to compile cleanly using VC 2005.</li>
	<li>Included info in ntservEventLogSource.cpp on how to find further info on 
	the various registry values which are required to create user defined event 
	logs.</li>
</ul>
<p><b>v1.67 (25 June 2006)</b></p>
<ul>
	<li>Combined the functionality of the _NTSERV_SERVICCONTROLMANAGER_DATA class 
	into the main CNTServiceControlManager class.</li>
	<li>Code now uses newer C++ style casts instead of C style casts.</li>
	<li>Combined the functionality of the _NTSERV_SCMSERVICE_DATA class into the 
	main CNTScmService class.</li>
	<li>Made the item data parameter to CNTScmService::EnumDependents a void* instead 
	of the current DWORD.</li>
	<li>Optimized CEventLogRecord constructor</li>
	<li>Combined the functionality of the _NTSERV_DATA class into the main CNTService 
	class.</li>
	<li>The class framework now requires the Platform SDK if compiled using VC 6.</li>
	<li>Fixed code which was not securely resetting the command line username and 
	password strings after they were used</li>
</ul>
<p><b>v1.68 (2 July 2006)</b></p>
<ul>
	<li>Optimized and tidied up DllMain code in TestSrvMsg.cpp</li>
	<li>All calls to m_EventLogSource.Report are now protected with &quot;if (m_bRegisterEventLogSource)&quot; 
	check</li>
	<li>Removed now unused Project configurations from the VC 6 workspace file.</li>
</ul>
<p><b>v1.69 (27 July 2006)</b></p>
<ul>
	<li>The static versions of the profile functions in CNTService have now been 
	renamed to include the word &quot;Service&quot; in their method names. This fixes a compiler 
	error when the code is used in VC 2005.</li>
</ul>
<p><b>v1.70 (1 August 2006)</b></p>
<ul>
	<li>Fix for two buffer size calculations using the new _tcscpy_s functions, 
	one in CNTEventLogSource::SetStringArrayIntoRegistry and the other in CNTService::GetDependencies. 
	Thanks to DmityShm on the codeproject forums for reporting this issue.</li>
</ul>
<p><b>v1.71 (21 September 2006)</b></p>
<ul>
	<li>Minor update to use %X instead of %x in various TRACE statements and CNTEventLogSource::Report 
	calls.</li>
</ul>
<p><b>20 November 2006</b></p>
<ul>
	<li>Minor update to use console I/O in the sample app instead of a MessageBox 
	in CMyService::ShowHelp.</li>
	<li>Optimized the member variable construction in CMyService::CMyService.</li>
</ul>
<p><b>v1.72 (2 February 2007)</b></p>
<ul>
	<li>Updated copyright details.</li>
	<li>Optimized CNTEventLog constructor code.</li>
	<li>Reworked CNTService::SetServiceToStatus to allow the last error value to 
	be reported back to client code. Thanks to Matthias Miller for reporting this 
	issue.</li>
	<li>Optimized calls to Win32ErrorToString.</li>
</ul>
<p><b>v1.73 (22 March 2007)</b></p>
<ul>
	<li>CNTService::SetServiceToStatus and CNTService::Uninstall no longer specifies 
	that it requires the SC_MANAGER_LOCK access right to connect to the SCM. This 
	change helps to allow services to be started and stopped from Power User accounts. 
	Thanks to Matthias Miller for reporting this issue.</li>
	<li>CNTService::SetServiceToStatus no longer specifies the STANDARD_RIGHTS_REQUIRED 
	access right when opening a service to control. This change helps to allow services 
	to be started and stopped from Power User accounts. Thanks to Matthias Miller 
	for reporting this issue.</li>
</ul>
<p><b>v1.74 (19 November 2007)</b></p>
<ul>
	<li>Minor update to display HRESULT&#39;s correctly.</li>
</ul>
<p><b>v1.75 (12 January 2008)</b></p>
<ul>
	<li>Updated copyright details.</li>
	<li>Provided a link to my blog in the html documentation with details on compiling 
	with VC 6.</li>
	<li>CNTService::Win32ErrorToString method has been reworked to now uses the 
	FORMAT_MESSAGE_IGNORE_INSERTS flag. For more information please see Raymond 
	Chen&#39;s blog at
	<a href="http://blogs.msdn.com/oldnewthing/archive/2007/11/28/6564257.aspx">
	http://blogs.msdn.com/oldnewthing/archive/2007/11/28/6564257.aspx</a>. Thanks 
	to Alexey Kuznetsov for reporting this issue.</li>
	<li>Updated the sample app to clean compile on VC 2008.</li>
	<li>SecureEmptyString method is now defined as &quot;FORCEINLINE&quot;.</li>
</ul>
<p><b>v1.76 (1 June 2008)</b></p>
<ul>
	<li>Code now compiles cleanly using Code Analysis (/analyze)</li>
	<li>The code has now been updated to support VC 2005 or later only.</li>
</ul>
<p><b>v1.77 (1 August 2010)</b></p>
<ul>
	<li>Updated copyright details. </li>
	<li>Updated the project settings to more modern default values. </li>
	<li>Fixed a trailing &quot;,&quot; in the definition of the &quot;ELErrorLoggingDetail&quot; enum
	</li>
	<li>Updated the sample app to compile cleanly on VC 2010 </li>
	<li>Updated the test code in App.cpp to only use the necessary rights when connecting 
	to the SCM or opening a specific service. This avoids Access denied errors on 
	Windows Vista or later when UAC is enabled. Thanks to Jan Bartels for reporting 
	this issue. </li>
	<li>Added support for the following SERVICE_CONTROL_* defines: SERVICE_CONTROL_SESSIONCHANGE, 
	SERVICE_CONTROL_PRESHUTDOWN, SERVICE_CONTROL_TIMECHANGE &amp; SERVICE_CONTROL_TRIGGEREVENT. 
	These control values represent new functionality for services on Windows Vista 
	and Windows 7 </li>
	<li>Added a comment to a #include to tell users to recompile TestSrvMsg if they 
	get a compile error for &quot;ntserv_msg.h&quot;. Thanks to Paul Pignon for reporting 
	this issue. </li>
	<li>Updated code to compile correctly using _ATL_CSTRING_EXPLICIT_CONSTRUCTORS 
	define </li>
	<li>Fixed a minor issue in CNTService::Win32ErrorToString with the use of printf 
	format identifiers </li>
	<li>Reworked all the internal heap memory management code to use ATL::CHeapPtr
	</li>
	<li>Reworked all the internal registry management code to use ATL::CRegKey
	</li>
	<li>The CNTService::m_bRegisterEventLogSource value has been renamed to m_bEventLogSource. 
	This is a breaking change and may require your service code to be updated if 
	you reference this value from your code. </li>
	<li>CNTService::Install has been refactored. Internally now this function calls 
	InstallEventLogSource and InstallServiceConfiguration </li>
	<li>Fixed a minor issue in CNTEventLogSource::Report with the use of printf 
	format identifiers </li>
	<li>CNTEventLogSource::Install method now supports CategoryCount, CategoryMessageFile 
	and ParameterMessageFile settings for event sources</li>
	<li>Included notes in documentation about using MSI in preference to &quot;/install&quot; 
	/ &quot;/uninstall&quot;</li>
	<li>Added support for NotifyServiceStatusChange</li>
	<li>Added support for ControlServiceEx</li>
	<li>Added support for SERVICE_CONFIG_DELAYED_AUTO_START_INFO </li>
	<li>Added support for SERVICE_CONFIG_FAILURE_ACTIONS_FLAG </li>
	<li>Added support for SERVICE_CONFIG_SERVICE_SID_INFO </li>
	<li>Added support for SERVICE_CONFIG_REQUIRED_PRIVILEGES_INFO </li>
	<li>Added support for SERVICE_CONFIG_PRESHUTDOWN_INFO </li>
	<li>Added support for SERVICE_CONFIG_TRIGGER_INFO </li>
	<li>Added support for SERVICE_CONFIG_PREFERRED_NODE </li>
	<li>CEventLogRecord::m_TimeGenerated and CEventLogRecord::m_TimeWritten values 
	are now simple DWORD values instead of CTime instances. </li>
	<li>Added support for GetEventLogInformation </li>
	<li>Carried out a thorough code review to ensure all functionality is correct 
	and functional on the Windows 7 and later</li>
</ul>
<p><b>v1.78 (3 September 2010)</b></p>
<ul>
	<li>Fixed a bug in CNTService::GetServiceProfileString where it would 
	incorrectly return FALSE.</li>
	<li>Fixed a bug in CNTService::GetServiceProfileInt where it would 
	incorrectly return FALSE.</li>
</ul>
<p><b>v1.79 (10 November 2012)</b></p>
<ul>
	<li>Updated copyright details.</li>
	<li>Updated sample service code to clean compile on VC 2012. </li>
	<li>Reworked CNTScmService::WaitForServiceStatus method to avoid the need 
	for calling GetTickCount.</li>
	<li>Fixed a bug in CNTEventLogSource::GetStringArrayFromRegistry where it 
	could not handle empty MULTI_SZ strings. Thanks to Rolf Schatten for 
	reporting this bug.</li>
	<li>CNTEventLogSource::Install now calls CRegKey::Create instead of CRegKey::Open 
	when installing the HKLM\SYSTEM\CurrentControlSet\Services\EventLog\&quot;LogName&quot; 
	registry key. This ensures that event log sources which are created with 
	custom LogName's will be installed correctly. Thanks to Rolf Schatten for 
	reporting this bug. </li>
</ul>
<p><b>v1.80 (1 January 2014)</b></p>
<ul>
	<li>Updated copyright details. </li>
	<li>Updated code to clean compile on VC 2013 </li>
	<li>Reworked the classes to optionally compile without MFC. By default the 
	classes now use STL for strings and arrays but if you define 
	CNTSERVICE_MFC_EXTENSIONS, the classes will revert back to using the MFC 
	collection classes. </li>
	<li>Updated the codebase to support all Service features upto Windows 8.1. 
	New features supported includes SERVICE_CONFIG_LAUCH_PROTECTED support 
	available via CNTScmService::QueryLaunchProtected and CNTScmService::ChangeLaunchProtected 
	and QueryServiceDynamicInformation support available via CNTService::QueryServiceDynamicInformation. </li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><a name="APIReference"></a>Class Framework Reference</h2>
<p>The framework consists of the following classes:</p>
<p>&nbsp;</p>
<p><b><a href="#CNTServiceCommandLineInfo">CNTServiceCommandLineInfo</a><br>
<a href="#sumCNTEventLogSource">CNTEventLogSource</a><br>
<a href="#sumCNTService">CNTService</a><br><a href="#sumCNTScmService">CNTScmService</a><br>
<a href="#sumCNTServiceControlManager">CNTServiceControlManager</a><br>
<a href="#sumCEventLogRecord">CEventLogRecord</a><br><a href="#sumCNTEventLog">CNTEventLog</a></b></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><a name="CNTServiceCommandLineInfo"></a><strong>CNTServiceCommandLineInfo</strong></p>
<p>The CNTServiceCommandLineInfo class aids in parsing the command line at application 
start-up. It is based almost exactly upon the way that the&nbsp; CCommandLineInfo 
class in MFC works.</p>
<p>A service application will typically create a local instance of this class in 
your main/wmain or InitInstance function. This object is then passed to CNTService::ParseCommandLine, 
which fills the CNTServiceCommandLineInfo object. The CNTServiceCommandLineInfo 
object is then passed to CNTService::ProcessShellCommand to handle the command-line 
arguments and flags.</p>
<p>You can use this object to encapsulate the following command-line options and 
parameters:</p>
<table border="0" cellpadding="7" cols="2">
	<colgroup>
	</colgroup>
	<tr>
		<td valign="top">
		<p class="th"><b>Command-line argument</b></p>
		</td>
		<td valign="top">
		<p class="th"><b>Command executed</b></p>
		</td>
	</tr>
	<tr>
		<td colspan="2" valign="top"></td>
	</tr>
	<tr>
		<td valign="top">
		<p class="tt">/install</p>
		</td>
		<td valign="top">
		<p class="tt">Installs the service.</p>
		</td>
	</tr>
	<tr>
		<td valign="top">
		<p class="tt">/remove | /uninstall</p>
		</td>
		<td valign="top">
		<p class="tt">Uninstalls the service.</p>
		</td>
	</tr>
	<tr>
		<td valign="top">
		<p class="tt">/help [ /?]</p>
		</td>
		<td valign="top">
		<p class="tt">Calls the virtual CNTService::OnHelp function.</p>
		</td>
	</tr>
	<tr>
		<td valign="top">/debug | /app | /Application</td>
		<td valign="top">Using this setting bypasses the service SCM start-up code 
		and instead runs your code as a standard application.</td>
	</tr>
	<tr>
		<td valign="top">/start</td>
		<td valign="top">Starts the service.</td>
	</tr>
	<tr>
		<td valign="top">/stop</td>
		<td valign="top">Stops the service.</td>
	</tr>
	<tr>
		<td valign="top">/pause</td>
		<td valign="top">Pauses the service.</td>
	</tr>
	<tr>
		<td valign="top">/continue</td>
		<td valign="top">Continues the service.</td>
	</tr>
	<tr>
		<td valign="top">/auto</td>
		<td valign="top">Installs the service as an automatic start-up service, 
		as opposed to a manual start-up service which is the default (should be 
		used in conjunction with the /install argument)</td>
	</tr>
	<tr>
		<td valign="top">/T:value</td>
		<td valign="top">A timeout value in milliseconds to use when uninstalling, 
		starting, stopping, pausing and continuing the service.</td>
	</tr>
	<tr>
		<td valign="top">/SCL:XYZ</td>
		<td valign="top">Provides the command line which the code should use when 
		running as a service by the SCM. (The use of this value on the command line 
		is dependent upon CNTService::m_bAllowCommandLine).</td>
	</tr>
	<tr>
		<td valign="top">/SD:WYZ</td>
		<td valign="top">Provides the service description to use. (The use of this 
		value on the command line is dependent upon CNTService::m_bAllowDescriptionChange).</td>
	</tr>
	<tr>
		<td valign="top">/SDN:PRQ</td>
		<td valign="top">Provides the service display name to use. (The use of this 
		value on the command line is dependent upon CNTService::m_bAllowDisplayNameChange).</td>
	</tr>
	<tr>
		<td valign="top">/SN:STU</td>
		<td valign="top">Provides the service name to use. (The use of this value 
		on the command line is dependent upon CNTService::m_bAllowNameChange).</td>
	</tr>
	<tr>
		<td valign="top">/silent</td>
		<td valign="top">Use this command line in conjunction with other command 
		line arguments to suppress any message boxes or console output which the 
		framework generates.</td>
	</tr>
	<tr>
		<td valign="top">/U:ABC</td>
		<td valign="top">Allows you to configure the username account under which 
		the service runs.</td>
	</tr>
	<tr>
		<td valign="top">/P:DEF</td>
		<td valign="top">Allows you to configure the password for the associated 
		username account under which the service runs.</td>
	</tr>
</table>
<p>Derive a new class from CCommandLineInfo to handle other flags and parameter 
values.</p>
<p>Please note that Install / Uninstall support via the CNTServiceCommandLineInfo 
class and the framework in general is considered self-registration. Installation 
best practices for Windows says that you should use the declarative approach provided 
by Windows Installer to install / uninstall your service. Please pick the MSI approach 
if you can.</p>
<p>&nbsp;</p>
<p><a name="sumCNTEventLogSource"></a><strong>CNTEventLogSource</strong></p>
<p>CNTEventLogSource provides a wrapper class for writing events to the NT event 
log. You could consider this as the server side to the Event log APIs.</p>
<p>&nbsp;</p>
<p><strong>Functions this class provides include:</strong></p>
<p><b><a href="#CNTEventLogSource">CNTEventLogSource<br></a>
<a href="#~CNTEventLogSource">~CNTEventLogSource<br></a><a href="#elsHandle">operator 
HANDLE<br></a><a href="#elsAttach">Attach<br></a><a href="#elsDetach">Detach<br>
</a><a href="#register">Register<br></a><a href="#Report">Report<br></a>
<a href="#Deregister">Deregister<br></a><a href="#elsInstall">Install<br></a>
<a href="#elsUninstall">Uninstall</a></b></p>
<p>&nbsp;</p>
<p><a name="CNTEventLogSource"></a><strong>CNTEventLogSource::CNTEventLogSource</strong></p>
<p><strong>CNTEventLogSource();</strong></p>
<p><strong>CNTEventLogSource(LPCTSTR </strong><i>lpUNCServerName</i><strong>, LPCTSTR
</strong><i>lpSourceName</i><strong>);</strong></p>
<p><strong>Remarks</strong></p>
<p>This is the constructor which just initializes all internal variables to a safe 
state.</p>
<p><strong>See Also </strong><a href="#~CNTEventLogSource">~CNTEventLogSource</a></p>
<p>&nbsp;</p>
<p><a name="~CNTEventLogSource"></a><strong>CNTEventLogSource::~CNTEventLogSource</strong></p>
<p><strong>~CNTEventLogSource();</strong></p>
<p><strong>Remarks</strong></p>
<p>This is the standard destructor for the class. Internally it will call
<a href="#register">Deregister</a> to ensure that any handle that is opened by this 
instance is closed</p>
<p><strong>See Also </strong><br><a href="#CNTEventLogSource">CNTEventLogSource</a>
<a href="#Deregister">Deregister</a></p>
<p>&nbsp;</p>
<p><a name="elsHandle"></a><strong>CNTEventLogSource::operator HANDLE</strong></p>
<p><strong>operator HANDLE() const;</strong></p>
<p><strong>Return Value:</strong></p>
<p>The underlying SDK handle representing this event log source.</p>
<p><strong>Remarks</strong></p>
<p>This function exposes the underlying handle which the CNTEventLogSource class 
wraps. This function is provided for integration with legacy code which uses the 
handle directly</p>
<p>&nbsp;</p>
<p><a name="elsAttach"></a><strong>CNTEventLogSource::Attach</strong></p>
<p><strong>BOOL Attach(HANDLE </strong><em>hEventSource</em><strong>);</strong></p>
<p><strong>Return Value</strong></p>
<p>TRUE if the function was successful, otherwise FALSE. To get extended error information, 
call GetLastError </p>
<p><strong>Parameters</strong></p>
<p><em>hEventSource</em> An SDK event log source handle returned from ::RegisterEventSource</p>
<p><strong>Remarks</strong></p>
<p>Use this member function to attach an existing SDK handle to a CNTEventLogSource.</p>
<p><strong>See Also</strong> <br><a href="#elsDetach">Detach</a></p>
<p>&nbsp;</p>
<p><a name="elsDetach"></a><strong>CNTEvenLogSource::Detach</strong></p>
<p><strong>HANDLE Detach();</strong></p>
<p><strong>Return Value</strong></p>
<p>The SDK event log source handle</p>
<p><strong>Remarks</strong></p>
<p>Call this function to detach m_hEventLogSource from the CNTEventLogSource object 
and&nbsp; set m_hEventLogSource to NULL.</p>
<p><strong>See Also</strong> <br><a href="#elsAttach">Attach</a></p>
<p>&nbsp;</p>
<p><a name="register"></a><strong>CNTEventLogSource::Register</strong></p>
<p><strong>BOOL Register(LPCTSTR </strong><em>lpUNCServerName</em><strong>, LPCTSTR
</strong><em>lpSourceName</em><strong>);</strong></p>
<p><strong>Return Value</strong></p>
<p>TRUE if the function was successful, otherwise FALSE. To get extended error information, 
call GetLastError </p>
<p><strong>Parameters</strong></p>
<p><i>lpUNCServerName</i> Pointer to a null-terminated string that specifies the 
Universal Naming Convention (UNC) name of the server on which this operation is 
to be performed. If this parameter is NULL, the operation is performed on the local 
computer. </p>
<p><i>lpSourceName</i> Pointer to a null-terminated string that specifies the name 
of the source referenced by the returned handle. The source name must be a sub key 
of a log file entry under the <b>EventLog</b> key in the registry. For example, 
&quot;WinApp&quot; is a valid source name if the registry has the following key: </p>
<p><code>HKEY_LOCAL_MACHINE <br>&nbsp; System <br>&nbsp;&nbsp;&nbsp; CurrentControlSet
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Services <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
EventLog <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Application
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WinApp
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Security <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
System <br></code><strong>Remarks</strong></p>
<p>Use this function to register a source of logging into the event log. Internally 
the CNTService class contains a member variable (m_EventLogSource) of type CNTEventLogSource 
which calls this function in its construction.</p>
<p><strong>See Also</strong> <br><a href="#elsDetach" name="de">Deregister</a></p>
<p>&nbsp;</p>
<p><a name="Report"></a><strong>CNTEventLogSource::Report</strong></p>
<p><strong>BOOL Report(WORD </strong><em>wType</em><strong>, WORD </strong><em>wCategory</em><strong>, 
DWORD </strong><em>dwEventID</em><strong>, PSID </strong><em>lpUserSid</em><strong>, 
WORD </strong><em>wNumStrings</em><strong>, DWORD </strong><em>dwDataSize</em><strong>, 
LPCTSTR* </strong><em>lpStrings</em><strong>, LPVOID </strong><em>lpRawData</em><strong>) 
const;</strong></p>
<p><b>BOOL Report(WORD </b><i>wType</i><b>, DWORD </b><i>dwEventID</i><b>);</b></p>
<p><b>BOOL Report(WORD </b><i>wType</i><b>, DWORD </b><i>dwEventID</i><b>, LPCTSTR
</b><i>lpszString</i><b>);</b></p>
<p><b>BOOL Report(WORD </b><i>wType</i><b>, DWORD </b><i>dwEventID</i><b>, LPCTSTR
</b><i>lpszString1</i><b>, LPCTSTR </b><i>lpszString2</i><b>);</b></p>
<p><b>BOOL Report(WORD </b><i>wType</i><b>, DWORD </b><i>dwEventID</i><b>, LPCTSTR
</b><i>lpszString1</i><b>, LPCTSTR </b><i>lpszString2</i><b>, DWORD </b><i>dwCode,
</i><b>BOOL </b><i>bReportAsHex </i><b>= TRUE);</b></p>
<p><b>BOOL Report(WORD </b><i>wType</i><b>, DWORD </b><i>dwEventID</i><b>, LPCTSTR
</b><i>lpszString</i><b>, DWORD </b><i>dwCode, </i><b>BOOL </b><i>bReportAsHex
</i><b>= TRUE);</b></p>
<p><b>BOOL Report(WORD </b><i>wType</i><b>, DWORD </b><i>dwEventID</i><b>, DWORD
</b><i>dwCode, </i><b>BOOL </b><i>bReportAsHex </i><b>= TRUE);</b></p>
<p><strong>Return Value</strong></p>
<p>TRUE if the function was successful, otherwise FALSE. To get extended error information, 
call GetLastError </p>
<p><strong>Parameters</strong></p>
<p><i>wType</i> Specifies the type of event being logged.</p>
<p><i>wCategory</i> Specifies the event category. This is source-specific information; 
the category can have any value. </p>
<p><i>dwEventID</i> Specifies the event. The event identifier specifies the message 
that goes with this event as an entry in the message file associated with the event 
source. </p>
<p><i>lpUserSid</i> Pointer to the current user&#39;s security identifier. This parameter 
can be NULL if the security identifier is not required. </p>
<p><i>wNumStrings</i> Specifies the number of strings in the array pointed to by 
the <i>lpStrings</i> parameter. A value of zero indicates that no strings are present.
</p>
<p><i>dwDataSize</i> Specifies the number of bytes of event-specific raw (binary) 
data to write to the log. If this parameter is zero, no event-specific data is present.
</p>
<p><i>lpStrings</i> Pointer to a buffer containing an array of null-terminated strings 
that are merged into the message from the message file before Event Viewer displays 
the string to the user. This parameter must be a valid pointer (or NULL), even if
<i>wNumStrings</i> is zero.</p>
<p><i>lpRawData</i> Pointer to the buffer containing the binary data. This parameter 
must be a valid pointer (or NULL), even if the <i>dwDataSize</i> parameter is zero.
</p>
<p><em>lpszString</em>, <em>lpszString1</em>, <em>lpszString2</em> Specifies a single 
string which will be merged into the message from the message file before Event 
Viewer displays the string to the user.</p>
<p><i>dwCode</i> A DWORD value to be put into the event log. Internally the code 
will convert it to an appropriate string representation.</p>
<p><i>bReportAsHex</i> Whether or not <i>&quot;dwCode&quot;</i> should be displayed as a hex 
representation or decimal.</p>
<p><strong>Remarks</strong></p>
<p>These 7 versions of Report, report a message to the event log. The versions are 
provided to allow the programmer to use the one most suitable for the particular 
situation at hand. </p>
<p>&nbsp;</p>
<p><a name="Deregister"></a><strong>CNTEventLogSource::Deregister</strong></p>
<p><strong>BOOL Deregister();</strong></p>
<p><strong>Return Value</strong></p>
<p>TRUE if the function was successful, otherwise FALSE. To get extended error information, 
call GetLastError </p>
<p><strong>Remarks</strong></p>
<p>Call this function to close the handle to the event log. This function will be 
called in the destructor in case you forget to close the handle yourself.</p>
<p><strong>See Also</strong> <br><a href="#register">Register</a></p>
<p>&nbsp;</p>
<p><a name="elsInstall"></a><strong>CNTEventLogSource::Install</strong></p>
<p><strong>static BOOL Install(LPCTSTR </strong><em>lpszLogName</em><strong>, LPCTSTR
</strong><em>lpSourceName</em><strong>, LPCTSTR </strong><em>lpEventMessageFile</em><strong>, 
LPCTSTR<em> pszEventCategoryMessageFile, </em>LPCTSTR<em> pszParameterMessageFile,</em> 
DWORD<em> dwTypesSupported, </em>DWORD<em> </em></strong><em>dwCategoryCount</em><strong>);</strong></p>
<p><strong>static BOOL Install(LPCTSTR </strong><em>lpSourceName</em><strong>, LPCTSTR
</strong><em>lpEventMessageFile</em><strong>, LPCTSTR</strong><em> pszEventCategoryMessageFile,
</em><strong>LPCTSTR</strong><em> pszParameterMessageFile,</em><strong> DWORD</strong><em> 
dwTypesSupported, </em><strong>DWORD</strong><em> dwCategoryCount</em><strong>);</strong></p>
<p><strong>Return Value</strong></p>
<p>TRUE if the function was successful, otherwise FALSE. To get extended error information, 
call GetLastError </p>
<p><strong>Parameters</strong></p>
<p><em>lpszLogName</em> The name of the event log to install to. Normally you would 
use &quot;Application&quot;.</p>
<p><em>lpSourceName</em> The name of the service which you want to install an event 
log source as. </p>
<p><em>lpEventMessageFile</em> The location of the binary where the Message table 
resource can be located. This can be a standard exe or dll.</p>
<p><em>lpEventCategoryMessageFile</em> Path to the category message file. A category 
message file contains language-dependent strings that describe the categories.
</p>
<p><em>lpEventParameterMessageFile</em> Path to the parameter message file. A parameter 
message file contains language-independent strings that are to be inserted into 
the event description strings. This value can be of type REG_SZ or REG_EXPAND_SZ.</p>
<p><em>dwTypesSupported</em> Specifies a bitmask of supported types.</p>
<p><em>dwCategoryCount</em> Number of event categories supported </p>
<p><strong>Remarks</strong></p>
<p>Call this function to setup the necessary entries in the registry so that the 
Event Viewer can correctly locate the message file for messages displayed in the 
event log. This function is called as part of CNTService::Install using appropriate 
values.</p>
<p><strong>See Also</strong> <br><a href="#elsUninstall">Uninstall</a></p>
<p>&nbsp;</p>
<p><a name="elsUninstall"></a><strong>CNTEventLogSource::Uninstall</strong></p>
<p><strong>static BOOL Uninstall(LPCTSTR </strong><em>lpSourceName</em><strong>);</strong></p>
<p><strong>Return Value</strong></p>
<p>TRUE if the function was successful, otherwise FALSE. To get extended error information, 
call GetLastError </p>
<p><strong>Remarks</strong></p>
<p>Call this function to remove the entries from the registry which were setup by 
the method Install.</p>
<p><strong>See Also</strong> <br><a href="#elsInstall">Install</a></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><a name="sumCNTService"></a><strong>CNTService</strong></p>
<p>CNTService is the class which provides a C++ framework upon which you can develop 
your own MFC C++ based services. The class makes heavy use of virtual functions 
which your service class should override.</p>
<p>&nbsp;</p>
<p><strong>Functions this class provides include:</strong></p>
<p><b><a href="#CNTService">CNTService<br></a><a href="#~CNTService">~CNTService<br>
</a><a href="#WriteProfileString">WriteProfileString<br></a>
<a href="#WriteProfileInt">WriteProfileInt<br></a><a href="#WriteProfileBinary">
WriteProfileBinary<br></a><a href="#WriteProfileStringArray">WriteProfileStringArray<br>
</a><a href="#GetProfileString">GetProfileString<br></a>
<a href="#GetProfileInt">GetProfileInt<br></a><a href="#GetProfileBinary">GetProfileBinary<br>
</a><a href="#GetProfileStringArray">GetProfileStringArray<br></a>
<a href="#ParseCommandLine">ParseCommandLine<br></a>
<a href="#ProcessShellCommand">ProcessShellCommand<br></a>
<a href="#ReportStatus">ReportStatus<br></a><a href="#RegisterCtrlHandler">RegisterCtrlHandler<br>
</a><a href="#ServiceCtrlHandler">ServiceCtrlHandler<br></a>
<a href="#ServiceMain">ServiceMain<br></a><a href="#OnStop">OnStop<br></a>
<a href="#OnPause">OnPause<br></a><a href="#OnContinue">OnContinue<br></a>
<a href="#OnInterrogate">OnInterrogate<br></a><a href="#OnShutDown">OnShutdown<br>
</a><a href="#OnUserDefinedRequest">OnUserDefinedRequest<br></a></b><b>
<a href="#OnNetBindDisable">OnParamChange</a><br><a href="#OnPowerEvent">OnHardwareProfileChange</a><br>
<a href="#OnPowerEvent">OnPowerEvent</a><br><a href="#OnNetBindAdd">OnNetBindAdd</a><br>
<a href="#OnNetBindRemove">OnNetBindRemove</a><br><a href="#OnNetBindEnable">OnNetBindEnable</a><br>
<a href="#OnNetBindDisable">OnNetBindDisable<br></a><a href="#OnDeviceEvent">OnDeviceEvent</a><br>
</b><b><a href="#Run">Run<br></a><a href="#Install">Install<br></a>
<a href="#Uninstall">Uninstall<br></a><a href="#Debug">Debug<br></a>
<a href="#ShowHelp">ShowHelp</a></b><br><b><a href="#EnumerateInstances">EnumerateInstances</a></b></p>
<p>&nbsp;</p>
<p><a name="CNTService"></a><strong>CNTService::CNTService</strong></p>
<p><strong>CNTService(); </strong></p>
<p><strong>CNTService(LPCTSTR </strong><em>lpszServiceName</em><strong>, LPCTSTR
</strong><em>lpszDisplayName</em><strong>, DWORD </strong><em>dwControlsAccepted,
</em><b>LPCTSTR </b><em>lpszDescription </em><b>= NULL</b><strong>); </strong>
</p>
<p><strong>Parameters</strong></p>
<p><em>lpszServiceName</em> Pointer to a null-terminated string that is the internal 
name of the service. </p>
<p><em>lpszDisplayName</em> Pointer to a null-terminated string that is to be used 
by user interface programs to identify this service.</p>
<p><em>dwControlsAccepted</em> Specifies the control codes that the service will 
accept and process. Any of the standard NT service codes as specified in the Platform 
SDK can be specified. </p>
<p>lpszDescription The textual description of the service. This appears in the new 
service&#39;s MMC snapin in Windows 2000 as the &quot;Description&quot; column. Using this value 
just means that administrators will see a comment associated with your service. 
The default value is NULL which will not insert a description into the registry.</p>
<p><strong>Remarks</strong></p>
<p>This is the standard constructor which initializes a number of internal variables 
based on the parameters sent in.</p>
<p><strong>See Also </strong><br><a href="#~CNTService">~CNTService</a></p>
<p>&nbsp;</p>
<p><a name="~CNTService"></a><strong>CNTService::~CNTService</strong></p>
<p><strong>~CNTService();</strong></p>
<p><strong>Remarks</strong></p>
<p>Standard destructor for the class</p>
<p><strong>See Also </strong><br><a href="#CNTService">CNTService</a></p>
<p>&nbsp;</p>
<p><a name="WriteProfileString"></a><strong>CNTService::WriteProfileString</strong></p>
<p><strong>BOOL WriteProfileString(LPCTSTR </strong><em>lpszSection</em><strong>, 
LPCTSTR </strong><em>lpszEntry</em><strong>, LPCTSTR </strong><em>lpszValue</em><strong>);</strong></p>
<p><strong>BOOL WriteServiceProfileString(LPCTSTR </strong>
<strong style="font-weight: 400"><i>lpszService</i>, </strong><strong>LPCTSTR
</strong><strong style="font-weight: 400"><i>lpszSection</i>, </strong><strong>LPCTSTR
</strong><strong style="font-weight: 400"><i>lpszEntry</i>, </strong><strong>LPCTSTR
</strong><strong style="font-weight: 400"><i>lpszValue</i>, </strong><strong>BOOL
</strong><strong style="font-weight: 400"><i>bFlush</i>, </strong><strong>DWORD*
</strong><strong style="font-weight: 400"><i>pLastError</i></strong><strong>);</strong></p>
<p><strong>Return Value</strong></p>
<p>TRUE if successful; otherwise FALSE.</p>
<p class="rl"><strong>Parameters</strong></p>
<p><em>lpszService</em> Points to a null-terminated string that specifies the service 
containing the entry.</p>
<p><i>bFlush </i>Should the setting be flushed to the registry</p>
<p><i>pLastError </i>If provided this parameter will contain the last error upon 
return</p>
<p><em>lpszSection</em> Points to a null-terminated string that specifies the section 
containing the entry. If the section does not exist, it is created. The name of 
the section is case independent; the string may be any combination of uppercase 
and lowercase letters.</p>
<p><em>lpszEntry</em> Points to a null-terminated string that contains the entry 
into which the value is to be written. If the entry does not exist in the specified 
section, it is created.</p>
<p><em>lpszValue</em> Points to the string to be written. If this parameter is NULL, 
the entry specified by the lpszEntry parameter is deleted. </p>
<p class="rl"><strong>Remarks</strong></p>
<p>Call this member function to write the specified string into the registry where 
Services are meant to store their configuration setting i.e. HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\ServiceName\Parameters.</p>
<p>&nbsp;</p>
<p><a name="WriteProfileInt"></a><strong>CNTService::WriteProfileInt</strong></p>
<p><strong>BOOL WriteProfileInt(LPCTSTR </strong><em>lpszSection</em><strong>, LPCTSTR
</strong><em>lpszEntry</em><strong>, int </strong><em>nValue</em><strong>);</strong></p>
<p><strong>BOOL WriteServiceProfileInt(LPCTSTR </strong>
<strong style="font-weight: 400"><i>lpszService</i>, </strong><strong>LPCTSTR
</strong><strong style="font-weight: 400"><i>lpszSection</i>, </strong><strong>LPCTSTR
</strong><strong style="font-weight: 400"><i>lpszEntry</i>, </strong><strong>int
</strong><strong style="font-weight: 400"><i>nValue</i>, </strong><strong>BOOL
</strong><strong style="font-weight: 400">bFlush, </strong><strong>DWORD*
</strong><strong style="font-weight: 400">pLastError</strong><strong>);</strong></p>
<p><strong>Return Value</strong></p>
<p>TRUE if successful; otherwise FALSE.</p>
<p class="rl"><strong>Parameters</strong></p>
<p><em>lpszService</em> Points to a null-terminated string that specifies the service 
containing the entry.</p>
<p><i>bFlush </i>Should the setting be flushed to the registry</p>
<p><i>pLastError </i>If provided this parameter will contain the last error upon 
return</p>
<p><em>lpszSection</em> Points to a null-terminated string that specifies the section 
containing the entry. If the section does not exist, it is created. The name of 
the section is case independent; the string may be any combination of uppercase 
and lowercase letters.</p>
<p><em>lpszEntry</em> Points to a null-terminated string that contains the entry 
into which the value is to be written. If the entry does not exist in the specified 
section, it is created.</p>
<p><em>nValue</em> Contains the value to be written.</p>
<p class="rl"><strong>Remarks</strong></p>
<p>Call this member function to write the specified value into the registry where 
Services are meant to store their configuration setting i.e. HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\ServiceName\Parameters.</p>
<p>&nbsp;</p>
<p><a name="WriteProfileBinary"></a><strong>CNTService::WriteProfileBinary</strong></p>
<p><strong>BOOL WriteProfileBinary(LPCTSTR </strong><em>lpszSection</em><strong>, 
LPCTSTR </strong><em>lpszEntry</em><strong>, LPBYTE </strong><em>pData</em><strong>, 
UINT </strong><em>nBytes</em><strong>);</strong></p>
<p><strong>BOOL WriteServiceProfileBinary(LPCTSTR </strong>
<strong style="font-weight: 400"><i>lpszService</i>, </strong><strong>LPCTSTR
</strong><strong style="font-weight: 400"><i>lpszSection</i>, </strong><strong>LPCTSTR
</strong><strong style="font-weight: 400"><i>lpszEntry</i>, </strong><strong>LPBYTE
</strong><strong style="font-weight: 400"><i>pData</i>, </strong><strong>UINT
</strong><strong style="font-weight: 400">nBytes, </strong><strong>BOOL </strong>
<strong style="font-weight: 400"><i>bFlush</i>, </strong><strong>DWORD* </strong>
<strong style="font-weight: 400">pLastError</strong><strong>);</strong></p>
<p><strong>Return Value</strong></p>
<p>TRUE if successful; otherwise FALSE.</p>
<p class="rl"><strong>Parameters</strong></p>
<p><em>lpszService</em> Points to a null-terminated string that specifies the service 
containing the entry.</p>
<p><i>bFlush </i>Should the setting be flushed to the registry</p>
<p><i>pLastError </i>If provided this parameter will contain the last error upon 
return</p>
<p><em>lpszSection</em> Points to a null-terminated string that specifies the section 
containing the entry. If the section does not exist, it is created. The name of 
the section is case independent; the string may be any combination of uppercase 
and lowercase letters.</p>
<p><em>lpszEntry</em> Points to a null-terminated string that contains the entry 
into which the value is to be written. If the entry does not exist in the specified 
section, it is created.</p>
<p><em>pData</em> Points to the binary data to be written.</p>
<p>nBytes The size of &quot;pData&quot; in bytes.</p>
<p class="rl"><strong>Remarks</strong></p>
<p>Call this member function to write the specified binary data into the registry 
where Services are meant to store their configuration setting i.e. HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\ServiceName\Parameters.</p>
<p>&nbsp;</p>
<p><a name="WriteProfileStringArray"></a><strong>CNTService::WriteProfileStringArray</strong></p>
<p><strong>BOOL WriteProfileStringArray(LPCTSTR </strong><em>lpszSection</em><strong>, 
LPCTSTR </strong><em>lpszEntry</em><strong>, const CStringArray&amp; </strong><em>array</em><strong>);</strong></p>
<p><b>BOOL WriteServiceProfileStringArray(LPCTSTR </b><i>lpszService</i>, <b>LPCTSTR
</b><i>lpszSection</i>, <b>LPCTSTR </b><i>lpszEntry</i>, <b>const CStringArray&amp;
</b><i>array</i>, <b>BOOL </b><i>bFlush</i>, <b>DWORD* </b><i>pLastError</i><b>);</b></p>
<p><strong>Return Value</strong></p>
<p>TRUE if successful; otherwise FALSE.</p>
<p class="rl"><strong>Parameters</strong></p>
<p><em>lpszService</em> Points to a null-terminated string that specifies the service 
containing the entry.</p>
<p><i>bFlush </i>Should the setting be flushed to the registry</p>
<p><i>pLastError </i>If provided this parameter will contain the last error upon 
return</p>
<p><em>lpszSection</em> Points to a null-terminated string that specifies the section 
containing the entry. If the section does not exist, it is created. The name of 
the section is case independent; the string may be any combination of uppercase 
and lowercase letters.</p>
<p><em>lpszEntry</em> Points to a null-terminated string that contains the entry 
into which the value is to be written. If the entry does not exist in the specified 
section, it is created.</p>
<p><em>array</em> The CStringArray to be written.</p>
<p class="rl"><strong>Remarks</strong></p>
<p>Call this member function to write the specified string array into the registry 
where Services are meant to store their configuration setting i.e. HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\ServiceName\Parameters. 
The value will be stored as a MULTI_SZ string in the registry.</p>
<p>&nbsp;</p>
<p><a name="GetProfileString"></a><strong>CNTService::GetProfileString</strong></p>
<p><strong>CString GetProfileString(LPCTSTR </strong><em>lpszSection</em><strong>, 
LPCTSTR </strong><em>lpszEntry</em><strong>, LPCTSTR </strong><em>lpszDefault</em><strong> 
= NULL</strong><em>, </em><b>DWORD* </b><i>pdwLastError</i><b> = NULL</b><strong>);</strong></p>
<p><strong>CString GetServiceProfileString(LPCTSTR </strong>
<strong style="font-weight: 400"><i>lpszService</i>, </strong><strong>LPCTSTR
</strong><strong style="font-weight: 400"><i>lpszSection</i>, </strong><strong>LPCTSTR
</strong><strong style="font-weight: 400"><i>lpszEntry</i>, </strong><strong>LPCTSTR
</strong><i><strong style="font-weight: 400">lpszDefault</strong></i><strong> = 
NULL</strong><strong style="font-weight: 400">, </strong><strong>DWORD* </strong>
<strong style="font-weight: 400"><i>pLastError</i></strong><strong> = NULL);</strong></p>
<p class="rl"><strong>Return Value</strong></p>
<p>The return value is the string from the registry or lpszDefault if the string 
cannot be found. The maximum string length supported by the framework is _MAX_PATH. 
If lpszDefault is NULL, the return value is an empty string.</p>
<p class="rl"><strong>Parameters</strong></p>
<p><em>lpszService</em> Points to a null-terminated string that specifies the service 
containing the entry.</p>
<p><i>bFlush </i>Should the setting be flushed to the registry</p>
<p><i>pLastError </i>If provided this parameter will contain the last error upon 
return</p>
<p><em>lpszSection</em> Points to a null-terminated string that specifies the section 
containing the entry.</p>
<p><em>lpszEntry</em> Points to a null-terminated string that contains the entry 
whose string is to be retrieved. This value must not be NULL.</p>
<p><em>lpszDefault</em> Points to the default string value for the given entry if 
the entry cannot be found in the registry.</p>
<p><i>pdwLastError</i> If this value is non-null, then upon return it will contain 
the value from the function GetLastError. This allows code to distinguish between 
a default value which is returned because it is actually stored as opposed to returning 
a default value because some of the registry API&#39;s failed.</p>
<p class="rl"><strong>Remarks</strong></p>
<p>Call this member function to retrieve the string associated with an entry within 
the specified section in the registry.</p>
<p>&nbsp;</p>
<p><a name="GetProfileInt"></a><strong>CNTService::GetProfileInt</strong></p>
<p><strong>UINT GetProfileInt(LPCTSTR </strong><em>lpszSection</em><strong>, LPCTSTR
</strong><em>lpszEntry</em><strong>, int </strong><em>nDefault, </em><b>DWORD*
</b><i>pdwLastError</i><b> = NULL</b><strong>);</strong></p>
<p><strong>UINT GetServiceProfileInt(LPCTSTR </strong>
<strong style="font-weight: 400"><i>lpszService</i>, </strong><strong>LPCTSTR
</strong><strong style="font-weight: 400"><i>lpszSection</i>, </strong><strong>LPCTSTR
</strong><strong style="font-weight: 400"><i>lpszEntry</i>, </strong><strong>int 
nDefault</strong><strong style="font-weight: 400">, </strong><strong>DWORD*
</strong><strong style="font-weight: 400"><i>pLastError</i></strong><strong> = NULL);</strong></p>
<p class="rl"><strong>Return Value</strong></p>
<p>The integer value of the string that follows the specified entry if the function 
is successful. The return value is the value of the nDefault parameter if the function 
does not find the entry.</p>
<p class="rl"><strong>Parameters</strong></p>
<p><em>lpszService</em> Points to a null-terminated string that specifies the service 
containing the entry.</p>
<p><i>bFlush </i>Should the setting be flushed to the registry</p>
<p><i>pLastError </i>If provided this parameter will contain the last error upon 
return</p>
<p><em>lpszSection</em> Points to a null-terminated string that specifies the section 
containing the entry.</p>
<p><em>lpszEntry</em> Points to a null-terminated string that contains the entry 
whose value is to be retrieved.</p>
<p>nDefault Specifies the default value to return if the framework cannot find the 
entry.</p>
<p><i>pdwLastError</i> If this value is non-null, then upon return it will contain 
the value from the function GetLastError. This allows code to distinguish between 
a default value which is returned because it is actually stored as opposed to returning 
a default value because some of the registry API&#39;s failed.</p>
<p class="rl"><strong>Remarks</strong></p>
<p>Call this member function to retrieve the value of an integer from an entry within 
a specified section in the registry. </p>
<p>This member function is not case sensitive, so the strings in the lpszSection 
and lpszEntry parameters may differ in case.</p>
<p>&nbsp;</p>
<p><a name="GetProfileBinary"></a><strong>CNTService::GetProfileBinary</strong></p>
<p><strong>BOOL GetProfileBinary(LPCTSTR </strong><em>lpszSection</em><strong>, 
LPCTSTR </strong><em>lpszEntry</em><strong>, LPBYTE* </strong><em>ppData</em><strong>, 
UINT* </strong><em>pBytes</em><strong>);</strong></p>
<p><strong>BOOL GetServiceProfileBinary(LPCTSTR </strong>
<strong style="font-weight: 400"><i>lpszService</i>, </strong><strong>LPCTSTR
</strong><strong style="font-weight: 400"><i>lpszSection</i>, </strong><strong>LPCTSTR
</strong><strong style="font-weight: 400"><i>lpszEntry</i>, </strong><strong>LPBYTE*
<i>ppData</i></strong><strong style="font-weight: 400">, </strong><strong>UINT*
</strong><strong style="font-weight: 400"><i>pBytes</i>, </strong><strong>DWORD*
</strong><strong style="font-weight: 400"><i>pLastError</i></strong><strong> = NULL);</strong></p>
<p><strong>Return Value</strong></p>
<p>TRUE if successful; otherwise FALSE.</p>
<p class="rl"><strong>Parameters</strong></p>
<p><em>lpszService</em> Points to a null-terminated string that specifies the service 
containing the entry.</p>
<p><i>bFlush </i>Should the setting be flushed to the registry</p>
<p><i>pLastError </i>If provided this parameter will contain the last error upon 
return</p>
<p><em>lpszSection</em> Points to a null-terminated string that specifies the section 
containing the entry.</p>
<p><em>lpszEntry</em> Points to a null-terminated string that contains the entry 
whose binary data is to be retrieved. This value must not be NULL.</p>
<p><em>ppData</em> Upon successful return, this pointer will contain the binary 
data read from the registry.</p>
<p>nBytes Upon successful return, this pointer will contain the size of the binary 
data read from the registry.</p>
<p class="rl"><strong>Remarks</strong></p>
<p>Call this member function to set a binary value associated with an entry within 
the specified section in the registry. Internally the data is stored in the registry 
as a REG_BINARY value. Note that the caller of the function is responsible for freeing 
the memory associated with the data in &quot;ppData&quot;. This can be achieved using: &quot;delete 
[] *ppData&quot;.</p>
<p>&nbsp;</p>
<p><a name="GetProfileStringArray"></a><strong>CNTService::GetProfileStringArray</strong></p>
<p><strong>BOOL GetProfileStringArray(LPCTSTR </strong><em>lpszSection</em><strong>, 
LPCTSTR </strong><em>lpszEntry</em><strong>, CStringArray&amp; </strong><em>array</em><strong>);</strong></p>
<p><strong>BOOL GetServiceProfileStringArray(LPCTSTR </strong>
<strong style="font-weight: 400"><i>lpszService</i>, </strong><strong>LPCTSTR
</strong><strong style="font-weight: 400"><i>lpszSection</i>, </strong><strong>LPCTSTR
</strong><strong style="font-weight: 400"><i>lpszEntry</i>, </strong><strong>CStringArray&amp;
</strong><strong style="font-weight: 400"><i>array</i>, </strong><strong>DWORD*
</strong><strong style="font-weight: 400">pLastError</strong><strong>);</strong></p>
<p><strong>Return Value</strong></p>
<p>TRUE if successful; otherwise FALSE.</p>
<p class="rl"><strong>Parameters</strong></p>
<p><em>lpszService</em> Points to a null-terminated string that specifies the service 
containing the entry.</p>
<p><i>bFlush </i>Should the setting be flushed to the registry</p>
<p><i>pLastError </i>If provided this parameter will contain the last error upon 
return</p>
<p><em>lpszSection</em> Points to a null-terminated string that specifies the section 
containing the entry.</p>
<p><em>lpszEntry</em> Points to a null-terminated string that contains the entry 
whose string array is to be retrieved. This value must not be NULL.</p>
<p><em>array </em>Upon successful return this will contain the CStringArray.</p>
<p class="rl"><strong>Remarks</strong></p>
<p>Call this member function to retrieve a string array associated with an entry 
within the specified section in the registry. The value is stored as a MULTI_SZ 
string in the registry.</p>
<p>&nbsp;</p>
<p><a name="ParseCommandLine"></a><strong>CNTService::ParseCommandLine</strong></p>
<p><strong>void ParseCommandLine(CNTServiceCommandLineInfo&amp; </strong><em>rCmdInfo</em><strong>);</strong></p>
<p class="rl"><strong>Parameters</strong></p>
<p><em>rCmdInfo</em> A reference to a
<a class="normal" href="#CNTServiceCommandLineInfo">CNTServiceCommandLineInfo</a> 
object.</p>
<p class="rl"><strong>Remarks</strong></p>
<p>Call this member function to parse the command line and send the parameters, 
one at a time, to CNTServiceCommandLineInfo::ParseParam.</p>
<p>&nbsp;</p>
<p><a name="ProcessShellCommand"></a><strong>CNTService::ProcessShellCommand</strong></p>
<p><strong>DWORD</strong><strong> ProcessShellCommand(CNTServiceCommandLineInfo&amp;
</strong><em>rCmdInfo</em><strong>);</strong></p>
<p class="rl"><strong>Return Value</strong></p>
<p>The Win32 error code if the shell command fails, otherwise ERROR_SUCCESS (0) 
if successful.</p>
<p class="rl"><strong>Parameters</strong></p>
<p><em>rCmdInfo</em> A reference to a
<a class="normal" href="#CNTServiceCommandLineInfo">CNTServiceCommandLineInfo</a> 
object.</p>
<p class="rl"><strong>Remarks</strong></p>
<p>This member function is called by your InitInstance, main or wmain to accept 
the parameters passed from the CNTServiceCommandLineInfo object identified by rCmdInfo, 
and perform the indicated action. </p>
<p>The &quot;m_nShellCommand&quot; data member of the CNTServiceCommandLineInfo object is 
of the following enumerated type, which is defined within the CNTServiceCommandLineInfo 
class.</p>
<pre>enum{
    RunAsService,
    StartTheService,
    PauseService,
    ContinueService,
    StopService,
    InstallService,
    UninstallService,
    DebugService,
    ShowServiceHelp
};</pre>
<pre>Please note that prior to v1.39, the return value from this function was a BOOL. Please ensure you review your code to make sure it correctly handles this change.</pre>
<p>&nbsp;</p>
<p><a name="ReportStatus"></a><strong>CNTService::ReportStatus</strong></p>
<p><strong>BOOL ReportStatus();</strong></p>
<p><b>BOOL ReportStatus(DWORD </b><i>dwCurrentState</i><b>, DWORD </b><i>dwCheckPoint</i><b> 
= STATE_NO_CHANGE, DWORD </b><i>dwWaitHint </i><b>= STATE_NO_CHANGE, DWORD </b>
<i>dwControlsAccepted</i><b> = STATE_NO_CHANGE);</b></p>
<p class="rl"><strong>Return Value</strong></p>
<p>TRUE if the SCM was notified successfully of this services state otherwise FALSE. 
To get extended error information, call GetLastError </p>
<p class="rl"><strong>Parameters</strong></p>
<p><em>dwCurrentState</em> Indicates the current state of the service.</p>
<p><em>dwWin32ExitCode</em> Specifies an Win32 error code that the service uses 
to report an error that occurs when it is starting or stopping. To return an error 
code specific to the service, the service must set this value to ERROR_SERVICE_SPECIFIC_ERROR 
to indicate that the <b>dwServiceSpecificExitCode</b> member contains the error 
code. The service should set this value to NO_ERROR when it is running and on normal 
termination. </p>
<p><em>dwServiceSpecificExitCode</em> Specifies a service specific error code that 
the service returns when an error occurs while the service is starting or stopping. 
This value is ignored unless the <b>dwWin32ExitCode</b> member is set to ERROR_SERVICE_SPECIFIC_ERROR.</p>
<p><em>dwCheckPoint</em> Specifies a value that the service increments periodically 
to report its progress during a lengthy start, stop, pause, or continue operation. 
For example, the service should increment this value as it completes each step of 
its initialization when it is starting up. The user interface program that invoked 
the operation on the service uses this value to track the progress of the service 
during a lengthy operation. This value is not valid and should be zero when the 
service does not have a start, stop, pause, or continue operation pending. </p>
<p><em>dwWaitHint</em> Specifies an estimate of the amount of time, in milliseconds, 
that the service expects a pending start, stop, pause, or continue operation to 
take before the service makes its next call to the <b>SetServiceStatus</b> function 
with either an incremented <b>dwCheckPoint</b> value or a change in <b>dwCurrentState</b>. 
If the amount of time specified by <b>dwWaitHint</b> passes, and <b>dwCheckPoint</b> 
has not been incremented, or <b>dwCurrentState</b> has not changed, the service 
control manager or service control program can assume that an error has occurred.
</p>
<p><em>dwControlsAccepted</em> Specifies the control codes that the service will 
accept and process. Any of the standard NT service codes as specified in the Platform 
SDK can be specified. These are the same codes as specified in the CNTService constructor.
</p>
<p class="rl"><strong>Remarks</strong></p>
<p>These two functions report the current state of the service back to the service 
control manager. The first versions uses the parameters specified and as well as 
updated the services own internal state will report it to the SCM. The second version 
uses the existing state of the service when reporting to the SCM.</p>
<p>&nbsp;</p>
<p><a name="RegisterCtrlHandler"></a><strong>CNTService::RegisterCtrlHandler</strong></p>
<p><strong>BOOL RegisterCtrlHandler();</strong></p>
<p class="rl"><strong>Return Value</strong></p>
<p>TRUE if the Control handler for this service was successfully registered otherwise 
FALSE. To get extended error information, call GetLastErrorr</p>
<p class="rl"><strong>Remarks</strong></p>
<p>This function is called automatically for you prior to the framework calling 
your ServiceMain code, so there is normally no need to call this function yourself. 
This function setups up the function on which the SCM will callback on when making 
requests to the service. Internally when a request is made it will be routed to 
the appropriate virtual function.</p>
<p><strong>See Also </strong><br><a href="#ServiceCtrlHandler">ServiceCtrlHandler</a></p>
<p>&nbsp;</p>
<p><a name="ServiceCtrlHandler"></a><strong>CNTService::ServiceCtrlHandler</strong></p>
<p><b>DWORD ServiceCtrlHandler(DWORD </b><i>dwControl</i><b>, DWORD </b><i>dwEventType</i><b>, 
LPVOID </b><i>lpEventData</i><b>)</b></p>
<p class="rl"><strong>Parameters</strong></p>
<p><em>dwControl</em> Specifies the requested control code.</p>
<dl>
	<i>dwEventType</i> The type of event that has occurred. <i>lpEventData</i> Additional 
	device information, if required
</dl>
<p>&nbsp;</p>
<p><strong>Remarks</strong></p>
<p>This function is called into by the SCM and internally it delegates to the appropriate 
virtual function. For example if a&nbsp; SERVICE_CONTROL_STOP request arrives then 
this function will call the virtual OnStop function. This function will not normally 
have to be overridden in your derived class. Please bear in mind that this function 
will be called in the context on the main thread on your service and not the thread 
in which your service does it main work (its ServiceMain handler).</p>
<p>&nbsp;</p>
<p><a name="ServiceMain"></a><strong>CNTService::ServiceMain</strong></p>
<p><strong>virtual void WINAPI ServiceMain(DWORD </strong><em>dwArgc</em><strong>, 
LPTSTR* </strong><em>lpszArgv</em><strong>);</strong> </p>
<dl>
	<p><strong>Parameters</strong></p>
</dl>
<p><i>dwArgc</i> Specifies the number of arguments in the <i>lpszArgv</i> array.</p>
<p><i>lpszArgv</i> Pointer to an array of pointers that point to null-terminated 
argument strings. The first argument in the array is the name of the service, and 
subsequent arguments are any strings passed to the service by the process that called 
the <a href="#scmsStart">CScmService::Start</a> function to start the service.
</p>
<p><strong>Remarks</strong></p>
<p>In your derived class you are responsible for writing your own <b>ServiceMain</b> 
function for your service</p>
<p>When a service control program requests that a new service run, the SCM starts 
the service and sends a start request to the control dispatcher. The control dispatcher 
creates a new thread to execute the <b>ServiceMain</b> function for the service.</p>
<p>The <b>ServiceMain</b> function should perform the following tasks: </p>
<ol>
	<li>Perform initialisation. If the execution time of the initialisation code 
	is expected to be very short (less than one second), initialisation can be performed 
	directly in <b>ServiceMain</b>, if not you should report back to the SCM using 
	the state START_PENDING. Check the sample service for the details on how this 
	is done.</li>
	<li>When initialisation is complete, call <b>SetServiceStatus</b>, specifying 
	the SERVICE_RUNNING state in the <b>SERVICE_STATUS</b> structure. </li>
	<li>Perform the service tasks, or, if there are no pending tasks, return. Any 
	change in the state of the service warrants a call to
	<a href="#ReportStatusToSCM">ReportStatusToSCM</a> to report new status information.
	</li>
	<li>If an error occurs while the service is initializing or running, the service 
	should call , specifying the SERVICE_STOP_PENDING state, if cleanup will be 
	lengthy. Once cleanup is complete, call <a href="#ReportStatusToSCM">ReportStatusToSCM</a> 
	from the last thread to terminate, specifying SERVICE_STOPPED in the <b>SERVICE_STATUS</b> 
	structure. Be sure to set the <b>dwServiceSpecificExitCode</b> and <b>dwWin32ExitCode</b> 
	members of the <b>SERVICE_STATUS</b> structure to identify the error. </li>
</ol>
<p>&nbsp;</p>
<p><a name="OnStop"></a><strong>CNTService::OnStop</strong></p>
<p><strong>virtual void OnStop();</strong></p>
<p><strong>Remarks</strong></p>
<p>This function will be called whenever a SERVICE_CONTROL_STOP request comes in 
from the SCM. Your derived class should do whatever is necessary to cause your service 
to stop.</p>
<p>&nbsp;</p>
<p><a name="OnPause"></a><strong>CNTService::OnPause</strong></p>
<p><strong>virtual void OnPause();</strong></p>
<p><strong>Remarks</strong></p>
<p>This function will be called whenever a SERVICE_CONTROL_PAUSE request comes in 
from the SCM. Your derived class should do whatever is necessary to cause your service 
to pause.</p>
<p>&nbsp;</p>
<p><a name="OnContinue"></a><strong>CNTService::OnContinue</strong></p>
<p><strong>virtual void OnContinue();</strong></p>
<p><strong>Remarks</strong></p>
<p>This function will be called whenever a SERVICE_CONTROL_CONTINUE request comes 
in from the SCM. Your derived class should do whatever is necessary to cause your 
service to continue.</p>
<p>&nbsp;</p>
<p><a name="OnInterrogate"></a><strong>CNTService::OnInterrogate</strong></p>
<p><strong>virtual void OnInterrogate();</strong></p>
<p><strong>Remarks</strong></p>
<p>This function will be called whenever a SERVICE_CONTROL_INTERROGATE request comes 
in from the SCM. The default implementation just calls
<a href="#ReportStatusToSCM">ReportStatusToSCM</a> to inform the SCM.</p>
<p>&nbsp;</p>
<p><a name="OnShutDown"></a><strong>CNTService::OnShutdown</strong></p>
<p><strong>virtual void OnShutdown();</strong></p>
<p><strong>Remarks</strong></p>
<p>This function will be called whenever a SERVICE_CONTROL_SHUTDOWN comes in from 
the SCM.&nbsp; Your derived class should do whatever is necessary to cause your 
service to shutdown.</p>
<p>&nbsp;</p>
<p><a name="OnUserDefinedRequest"></a><strong>CNTService::OnUserDefinedRequest</strong></p>
<p><strong>virtual void OnUserDefinedRequest(DWORD </strong><em>dwControl</em><strong>);</strong></p>
<p><strong>Remarks</strong></p>
<p>This function will be called whenever a user defined request comes in from the 
SCM.&nbsp; Your derived class should do whatever is appropriate for its service. 
In the example service provided, it simply changes the frequency of beeps emitted 
by the service.</p>
<p>&nbsp;</p>
<p><a name="OnParamChange"></a><strong>CNTService::OnParamChange</strong></p>
<p><strong>virtual void OnParamChange();</strong></p>
<p><strong>Remarks</strong></p>
<p>Notifies the service that service-specific startup parameters have changed. The 
service should reread its startup parameters. This is only called when the service 
is running on Windows 2000 or later.</p>
<p>&nbsp;</p>
<p><a name="OnHardwareProfileChange"></a><strong>CNTService::OnHardwareProfileChange</strong></p>
<p><strong>virtual DWORD OnHardwareProfileChange</strong><b>(DWORD </b><i>dwEventType</i><b>, 
LPVOID </b><i>lpEventData</i><b>);</b></p>
<p class="rl"><strong>Return Value</strong></p>
return NO_ERROR to grant the request and an error code to deny the request.
<p class="rl"><strong>Parameters</strong></p>
<p><em>dwEventType</em> this parameter can be one of the following values: <b>DBT</b>_<b>CONFIGCHANGED</b>,
<b>DBT</b>_<b>QUERYCHANGECONFIG</b>, or <b>DBT</b>_<b>CONFIGCHANGECANCELED</b>.</p>
<p><i>lpEventData</i> Additional device information, if required. The format of 
this data depends on the value of <i>dwEventType</i> parameter.</p>
<p><strong>Remarks</strong></p>
<p>Notifies the service that the computer&#39;s hardware profile has changed. This is 
only called when the service is running on Windows 2000 or later.</p>
<p>&nbsp;</p>
<p><a name="OnPowerEvent"></a><strong>CNTService::OnPowerEvent</strong></p>
<p><strong>virtual DWORD OnPowerEvent</strong><b>(DWORD </b><i>dwEventType</i><b>, 
LPVOID </b><i>lpEventData</i><b>);</b></p>
<p class="rl"><strong>Return Value</strong></p>
return NO_ERROR to grant the request and an error code to deny the request.
<p class="rl"><strong>Parameters</strong></p>
<p><em>dwEventType</em> this parameter can be one of the values specified in the
<i>wParam</i> value of the <b>WM_POWERBROADCAST</b> message.</p>
<p><i>lpEventData</i> This data corresponds to the <i>lParam</i> value that applications 
receive as part of a <b>WM_POWERBROADCAST</b> message.</p>
<p><strong>Remarks</strong></p>
<p>Notifies the service of system power events. This is only called when the service 
is running on Windows 2000 or later.</p>
<p>&nbsp;</p>
<p><a name="OnNetBindAdd"></a><strong>CNTService::OnNetBindAdd</strong></p>
<p><b>virtual void OnNetBindAdd();</b></p>
<p><strong>Remarks</strong></p>
<p>Notifies a network service that there is a new component for binding. The service 
should bind to the new component. This is only called when the service is running 
on Windows 2000 or later.</p>
<p>&nbsp;</p>
<p><a name="OnNetBindRemove"></a><strong>CNTService::OnNetBindRemove</strong></p>
<p><b>virtual void OnNetBindRemove();</b></p>
<p><strong>Remarks</strong></p>
<p>Notifies a network service that a component for binding has been removed. The 
service should reread its binding information and unbind from the removed component. 
This is only called when the service is running on Windows 2000 or later.</p>
<p>&nbsp;</p>
<p><a name="OnNetBindEnable"></a><strong>CNTService::OnNetBindEnable</strong></p>
<p><b>virtual void OnNetBindEnable();</b></p>
<p><strong>Remarks</strong></p>
<p>Notifies a network service that a disabled binding has been enabled. The service 
should reread its binding information and add the new binding. This is only called 
when the service is running on Windows 2000 or later.</p>
<p>&nbsp;</p>
<p><a name="OnNetBindDisable"></a><strong>CNTService::OnNetBindDisable</strong></p>
<p><b>virtual void OnNetBindDisable();</b></p>
<p><strong>Remarks</strong></p>
<p>Notifies a network service that one of its bindings has been disabled. The service 
should reread its binding information and remove the binding. This is only called 
when the service is running on Windows 2000 or later.</p>
<p>&nbsp;</p>
<p><a name="OnDeviceEvent"></a><strong>CNTService::OnDeviceEvent</strong></p>
<p><strong>virtual DWORD OnDeviceEvent</strong><b>(DWORD </b><i>dwEventType</i><b>, 
LPVOID </b><i>lpEventData</i><b>);</b></p>
<p class="rl"><strong>Return Value</strong></p>
return NO_ERROR to grant the request and an error code to deny the request.
<p class="rl"><strong>Parameters</strong></p>
<p><em>dwEventType</em> this parameter can be one of the following values: <b>DBT</b>_<b>DEVICEARRIVAL</b>,
<b>DBT</b>_<b>DEVICEREMOVECOMPLETE</b>, <b>DBT</b>_<b>DEVICEQUERYREMOVE</b>, <b>
DBT</b>_<b>DEVICEQUERYREMOVEFAILED</b>, <b>DBT</b>_<b>DEVICEREMOVEPENDING</b>, or
<b>DBT</b>_<b>CUSTOMEVENT</b></p>
<p><i>lpEventData</i> This data corresponds to the <i>lParam</i> value that applications 
receive as part of a <b>WM_DEVICECHANGE</b> message.</p>
<p><strong>Remarks</strong></p>
<p>Notifies the service of device events. The service must register to receive these 
notifications by using the <b>RegisterDeviceNotification</b> function. This is only 
called when the service is running on Windows 2000 or later.</p>
<p>&nbsp;</p>
<p><a name="Run"></a><strong>CNTService::Run</strong></p>
<p><strong>virtual BOOL Run();</strong></p>
<p><strong>Remarks</strong></p>
<p>Calling this function will cause a service to start running. Internally it will 
set up an appropriate SERVICE_TABLE_ENTRY array and call StartServiceCtrlDispatcher 
to kick of the service. You would normally call this in your main, wmain or InitInstance. 
If you are using the <a href="#CNTServiceCommandLineInfo">CNTServiceCommandLineInfo</a> 
class and <a href="#ParseCommandLine">ParseCommandLine</a> and
<a href="#ProcessShellCommand">ProcessShellCommand</a> member functions of CNTService 
then there is no need to call this function.</p>
<p>&nbsp;</p>
<p><a name="Install"></a><strong>CNTService::Install</strong></p>
<p><strong>virtual BOOL Install(CString&amp; </strong>
<strong style="font-weight: 400"><i>sErrorMsg</i>, </strong><strong>DWORD&amp;
</strong><strong style="font-weight: 400"><i>dwError</i>);</strong></p>
<p><strong>Remarks</strong></p>
<p>This will install a service. Internally it will call into the SCM API to set 
this service up as an On demand service with no dependencies. It will also install 
the service so that it can report events to the event log as well as letting Event 
Viewer filter using the friendly name of the service. This function will be called 
internally by the <a href="#CNTServiceCommandLineInfo">CNTServiceCommandLineInfo</a> 
if &quot;/install&quot; is specified on the command line.</p>
<p>&nbsp;</p>
<p><a name="Uninstall"></a><strong>CNTService::Uninstall</strong></p>
<p><strong>virtual BOOL Uninstall(CString&amp; </strong>
<strong style="font-weight: 400"><i>sErrorMsg</i>, </strong><strong>DWORD&amp;
</strong><strong style="font-weight: 400"><i>dwError</i>, </strong><strong>DWORD
</strong><strong style="font-weight: 400"><i>dwTimeToWaitForStop</i>);</strong></p>
<p><strong>Remarks</strong></p>
<p>The is the corollary function of Install and will remove the service from the 
SCM database and unregister its&#39; event log registry entries. Please bear in mind 
that once this is done, event viewer will no longer be able to correctly display 
any messages the service generated while it was installed. the
<a href="#CNTServiceCommandLineInfo">CNTServiceCommandLineInfo</a> if &quot;-uninstall&quot; 
or &quot;-remove&quot; is specified on the command line.</p>
<p>&nbsp;</p>
<p><a name="Debug"></a><strong>CNTService::Debug</strong></p>
<p><strong>virtual void Debug();</strong></p>
<p><strong>Remarks</strong></p>
<p>This will run a service without interacting with the SCM, in effect a &quot;debug&quot; 
or &quot;Application&quot; mode. This helps when testing your application as it will stop 
the SCM from timing out your service as it is being debugged. Internally this function 
will just call the ServiceMain function of your class. Remember that in this case 
your service code will be running in the same thread as the main thread so it may 
mask problems which only arise when the code is executed as a real service. This 
function will be called internally by <a href="#CNTServiceCommandLineInfo">CNTServiceCommandLineInfo</a> 
if &quot;/debug&quot;, /Application or /App is specified on the command line.</p>
<p>&nbsp;</p>
<p><a name="ShowHelp"></a><strong>CNTService::ShowHelp</strong></p>
<p><strong>virtual void ShowHelp();</strong></p>
<p><strong>Remarks</strong></p>
<p>This function will be called internally by
<a href="#CNTServiceCommandLineInfo">CNTServiceCommandLineInfo</a> if &quot;-help&quot; or 
&quot;-?&quot; is specified on the command line. It is up to you to either print some message 
to the console if you are developing a console mode service or display some helpful 
window if its a GUI app. The sample service simply displays a message using AfxMessageBox 
as it was developed using the GUI subsystem.</p>
<p>&nbsp;</p>
<p><strong><a name="EnumerateInstances"></a>CNTService::EnumerateInstances</strong></p>
<p><strong>virtual BOOL EnumerateInstances(CStringArray&amp; </strong>
<strong style="font-weight: 400"><i>ServiceNames, </i></strong><strong>DWORD&amp;
</strong><i><strong style="font-weight: 400">dwError</strong></i><strong>);</strong></p>
<p><strong>Return Value</strong></p>
<p>TRUE if successful; otherwise FALSE.</p>
<p class="rl"><strong>Parameters</strong></p>
<p><em>ServiceNames</em> Upon return will contain all the service name instances 
for this service.</p>
<p><em>dwError </em>Will contain the last error code upon return.</p>
<p class="rl"><strong>Remarks</strong></p>
<p>Call this member function to enumerate all instances of the service. This could 
prove useful where you are writing configuration type applets which configure the 
settings for all the instances of your installed service.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><a name="sumCNTScmService"></a><strong>CNTScmService</strong></p>
<p>CNTScmService is a class which encapsulates a service as returned from the Service 
Control Manager, in effect a SC_HANDLE. An instance of a CNTScmService is usually 
acquired by a call to CNTServiceControlManager::Open. Once retrieved the class allows 
you to control the service, change its configuration and query a service&#39;s state.</p>
<p>&nbsp;</p>
<p><strong>Functions this class provides include:</strong></p>
<p><b><a href="#CNTScmSevice">CNTScmService<br></a><a href="#~CNTScmSevice">~CNTScmService<br>
</a><a href="#scmsClose">Close<br></a><a href="#scmsHandle">operator SC_HANDLE<br>
</a><a href="#scmsAttach">Attach<br></a><a href="#scmsDetach">Detach<br></a>
<a href="#scmsChangeConfig">ChangeConfig<br></a><a href="#scmsControl">Control<br>
</a><a href="#scmsStop">Stop<br></a><a href="#scmsPause">Pause<br></a>
<a href="#scmsContinue">Continue<br></a><a href="#scmsInterrogate">Interrogate<br>
</a><a href="#scmsStart">Start<br></a><a href="#scmsStop">AcceptStop<br></a>
<a href="#scmsAcceptPauseContinue">AcceptPauseContinue<br></a>
<a href="#scmsAcceptShutdown">AcceptShutdown<br></a><a href="#scmsQueryStatus">QueryStatus<br>
</a><a href="#scmsQueryConfig">QueryConfig<br></a><a href="#scmsCreate">Create<br>
</a><a href="#scmsDelete">Delete<br></a><a href="#scmsEnumDependents">EnumDependents<br>
</a><a href="#scmsQueryObjectSecurity">QueryObjectSecurity<br></a>
<a href="#scmsSetObjectSecurity">SetObjectSecurity<br></a>
<a href="#ChangeFailureActions">ChangeDescription</a><br>
<a href="#ChangeFailureActions">QueryDescription</a><br>
<a href="#QueryFailureActions">QueryFailureActions</a><br>
<a href="#ChangeFailureActions">ChangeFailureActions</a></b><br><strong>
<a href="#ChangeDelayAutoStart">ChangeDelayAutoStart</a><br>
<a href="#QueryDelayAutoStart">QueryDelayAutoStart</a><br>
<a href="#ChangeFailureActionsFlag">ChangeFailureActionsFlag</a><br>
<a href="#QueryFailureActionsFlag">QueryFailureActionsFlag</a><br>
<a href="#ChangeSidType">ChangeSidType</a><br><a href="#QuerySidType">QuerySidType</a><br>
<a href="#ChangeRequiredPrivileges">ChangeRequiredPrivileges</a><br>
<a href="#QueryRequiredPrivileges">QueryRequiredPrivileges</a><br>
<a href="#ChangePreShutdown">ChangePreShutdown</a><br>
<a href="#QueryPreShutdown">QueryPreShutdown</a><br><a href="#ChangeTrigger">ChangeTrigger</a><br>
<a href="#QueryTrigger">QueryTrigger</a><br><a href="#QueryPreferredNode">ChangePreferredNode</a><br>
<a href="#QueryPreferredNode">QueryPreferredNode</a><br>
<a href="#NotifyStatusChange">NotifyStatusChange</a></strong></p>
<p>&nbsp;</p>
<p><a name="CNTScmSevice"></a><strong>CNTScmService::CNTScmService</strong></p>
<p><strong>CNTScmService();</strong></p>
<p><strong>Remarks</strong></p>
<p>This is the default constructor which just initializes all internal variables 
to a safe state.</p>
<p><strong>See Also </strong><br><a href="#~CNTScmSevice">~CNTScmService</a></p>
<p>&nbsp;</p>
<p><a name="~CNTScmSevice"></a><strong>CNTScmService::~CNTScmService</strong></p>
<p><strong>~CNTScmService();</strong></p>
<p><strong>Remarks</strong></p>
<p>This is the standard destructor for the class. Internally it will call
<a href="#scmsClose">Close</a> to ensure that any handle that is opened by this 
instance is closed</p>
<p><strong>See Also <br></strong><a href="#CNTScmSevice">CNTScmService</a>
<a href="#scmsClose">Close</a></p>
<p>&nbsp;</p>
<p><a name="scmsClose"></a><strong>CNTScmService::Close</strong></p>
<p><strong>void Close();</strong></p>
<p><strong>Remarks</strong></p>
<p>This frees the SC_HANDLE by internally calling CloseServiceHandle which this 
class encapsulates.</p>
<p>&nbsp;</p>
<p><a name="scmsHandle"></a><strong>CNTScmService::operator SC_HANDLE</strong></p>
<p><strong>operator SC_HANDLE() const;</strong></p>
<p><strong>Return Value:</strong></p>
<p>The underlying SDK service handle representing this class.</p>
<p><strong>Remarks</strong></p>
<p>This function exposes the underlying handle which the CNTScmService class wraps. 
This function is provided for integration with legacy code which uses the handle 
directly.</p>
<p>&nbsp;</p>
<p><a name="scmsAttach"></a><strong>CNTScmService::Attach</strong></p>
<p><strong>BOOL Attach(SC_HANDLE </strong><em>hService</em><strong>);</strong></p>
<p><strong>Return Value</strong></p>
<p>TRUE if the function was successful, otherwise FALSE. To get extended error information, 
call GetLastError </p>
<p><strong>Parameters</strong></p>
<p><em>hService</em> An SDK service handle returned from SDK calls to the SCM APIs</p>
<p><strong>Remarks</strong></p>
<p>Use this member function to attach an existing SDK handle to a CNTScmService.</p>
<p><strong>See Also</strong> <br><a href="#scmsDetach">Detach</a></p>
<p>&nbsp;</p>
<p><a name="scmsDetach"></a><strong>CNTScmService::Detach</strong></p>
<p><strong>SC_HANDLE Detach();</strong></p>
<p><strong>Return Value</strong></p>
<p>The SDK service handle</p>
<p><strong>Remarks</strong></p>
<p>Call this function to detach m_hService from the CNTScmService object and&nbsp; 
set m_hService to NULL.</p>
<p><strong>See Also</strong> <br><a href="#scmsAttach">Attach</a></p>
<p>&nbsp;</p>
<p><a name="scmsChangeConfig"></a><strong>CNTScmService::ChangeConfig</strong></p>
<p><strong>BOOL ChangeConfig(DWORD </strong><em>dwServiceType</em><strong>, DWORD
</strong><em>dwStartType</em><strong>, DWORD </strong><em>dwErrorControl</em><strong>, 
LPCTSTR </strong><em>lpBinaryPathName</em><strong>, LPCTSTR </strong><em>lpLoadOrderGroup</em><strong>, 
LPDWORD </strong><em>lpdwTagId</em><strong>, LPCTSTR </strong><em>lpDependencies</em><strong>, 
LPCTSTR </strong><em>lpServiceStartName</em><strong>, LPCTSTR </strong><em>lpPassword</em><strong>, 
LPCTSTR </strong><em>lpDisplayName</em><strong>) const;</strong></p>
<p><strong>Remarks</strong></p>
<p>This is a simple wrapper for the SDK call ChangeServiceConfig. See the SDK for 
full details on this function.</p>
<p>&nbsp;</p>
<p><a name="scmsControl"></a><strong>CNTScmService::Control</strong></p>
<p><strong>BOOL Control(DWORD </strong><em>dwControl</em><strong>);<br>DWORD Control(DWORD
</strong><em>dwControl</em><strong>, DWORD </strong><em>dwInfoLevel</em><strong>, 
PVOID </strong><em>pControlParams</em><strong>) </strong></p>
<p class="rl"><strong>Parameters</strong></p>
<p><em>dwControl</em> Specifies the control code to send to this service.</p>
<p><strong>Remarks</strong></p>
<p>This is a simple wrapper for the SDK call ControlService. The version which has 
three parameters is a simple wrapper for the SDK call COntrolServiceEX.</p>
<p>&nbsp;</p>
<p><a name="scmsStop"></a><strong>CNTScmService::Stop</strong></p>
<p><strong>BOOL Stop() const;</strong></p>
<p><strong>Remarks</strong></p>
<p>This is a simple wrapper for calling <a href="#scmsControl">Control</a> with 
the parameter SERVICE_CONTROL_STOP</p>
<p>&nbsp;</p>
<p><a name="scmsPause"></a><strong>CNTScmService::Pause</strong></p>
<p><strong>BOOL Pause() const;</strong></p>
<p><strong>Remarks</strong></p>
<p>This is a simple wrapper for calling <a href="#scmsControl">Control</a> with 
the parameter SERVICE_CONTROL_PAUSE</p>
<p>&nbsp;</p>
<p><a name="scmsContinue"></a><strong>CNTScmService::Continue</strong></p>
<p><strong>BOOL Continue() const;</strong></p>
<p><strong>Remarks</strong></p>
<p>This is a simple wrapper for calling <a href="#scmsControl">Control</a> with 
the parameter SERVICE_CONTROL_CONTINUE</p>
<p>&nbsp;</p>
<p><a name="scmsInterrogate"></a><strong>CNTScmService::Interrogate</strong></p>
<p><strong>BOOL Interrogate() const;</strong></p>
<p><strong>Remarks</strong></p>
<p>This is a simple wrapper for calling <a href="#scmsControl">Control</a> with 
the parameter SERVICE_CONTROL_INTERROGATE</p>
<p>&nbsp;</p>
<p><a name="scmsStart"></a><strong>CNTScmService::Start</strong></p>
<p><strong>BOOL Start(DWORD </strong><em>dwNumServiceArgs</em><strong>, LPCTSTR*
</strong><em>lpServiceArgVectors</em><strong>) const;</strong></p>
<p><strong>Parameters</strong></p>
<p><i>dwNumServiceArgs</i> Specifies the number of argument strings in the <i>lpServiceArgVectors</i> 
array. If <i>lpServiceArgVectors</i> is NULL, this parameter can be zero. </p>
<p><i>lpServiceArgVectors</i> Pointer to an array of pointers that point to null-terminated 
argument strings passed to a service. Driver services do not receive these arguments. 
If no arguments are passed to the service being started, this parameter can be NULL.
</p>
<p><strong>Return Values</strong></p>
<p>TRUE If the function succeeds otherwise FALSE. To get extended error information, 
call <b>GetLastError</b>. </p>
<p><strong>Remarks</strong></p>
<p>Starts this service with the specified parameters.</p>
<p>&nbsp;</p>
<p><a name="scmsAcceptStop"></a><strong>CNTScmService::AcceptStop</strong></p>
<p><strong>BOOL AcceptStop(BOOL&amp; </strong><em>bStop</em><strong>);</strong></p>
<p><strong>Parameters</strong></p>
<p><i>bStop</i> Upon a successful return from this function, bStop will indicate 
whether this service can be stopped. </p>
<p><strong>Return Values</strong></p>
<p>TRUE If the function succeeds otherwise FALSE. To get extended error information, 
call GetLastError. </p>
<p><strong>Remarks</strong></p>
<p>Queries this service to determine if this service can currently be stopped.</p>
<p>&nbsp;</p>
<p><a name="scmsAcceptPauseContinue"></a><strong>CNTScmService::AcceptPauseContinue</strong></p>
<p><strong>BOOL AcceptPauseContinue(BOOL&amp; </strong><em>bPauseContinue</em><strong>);</strong></p>
<p><strong>Parameters</strong></p>
<p><i>bPauseContinue</i> Upon a successful return from this function, bPauseContinue 
will indicate whether this service can be paused and continued. </p>
<p><strong>Return Values</strong></p>
<p>TRUE If the function succeeds otherwise FALSE. To get extended error information, 
call GetLastError. </p>
<p><strong>Remarks</strong></p>
<p>Queries this service to determine if this service can currently be paused / continued.</p>
<p>&nbsp;</p>
<p><a name="scmsAcceptShutdown"></a><strong>CNTScmService::AcceptShutdown</strong></p>
<p><strong>BOOL AcceptShutdown(BOOL&amp; </strong><em>bShutdown</em><strong>);</strong></p>
<p><strong>Parameters</strong></p>
<p><i>bShutdown</i> Upon a successful return from this function, bShutdown will 
indicate whether this service handles the shutdown request. </p>
<p><strong>Return Values</strong></p>
<p>TRUE If the function succeeds otherwise FALSE. To get extended error information, 
call GetLastError.</p>
<p><strong>Remarks</strong></p>
<p>Queries this service to determine if this service handles the shutdown request.</p>
<p>&nbsp;</p>
<p><a name="scmsQueryStatus"></a><strong>CNTScmService::QueryStatus</strong></p>
<p><strong>BOOL QueryStatus(SERVICE_STATUS&amp; </strong><em>ServiceStatus</em><strong>) 
const;</strong></p>
<p><b>BOOL QueryStatus(SERVICE_STATUS_PROCESS&amp; </b><i>ssp</i><b>) const;</b></p>
<p><strong>Parameters</strong></p>
<p><i>ServiceStatus</i> Upon a successful return from this function, ServiceStatus 
will contain the current status of this service. </p>
<p><i>ssp</i> Upon a successful return from this function, ssp will contain detailed 
info about the current status of this service. </p>
<p><strong>Return Values</strong></p>
<p>TRUE If the function succeeds otherwise FALSE. To get extended error information, 
call GetLastError. </p>
<p><strong>Remarks</strong></p>
<p>Queries this service for its current status. The overridden version which takes 
a SERVICE_STATUS_PROCESS structure is only available on Windows 2000.</p>
<p>&nbsp;</p>
<p><a name="scmsQueryConfig"></a><strong>CNTScmService::QueryConfig</strong></p>
<p><strong>BOOL QueryConfig(LPQUERY_SERVICE_CONFIG&amp; </strong><em>lpServiceConfig</em><strong>) 
const;</strong></p>
<p><strong>Parameters</strong></p>
<p><i>lpServiceConfig</i> Upon a successful return from this function, lpServiceConfig 
will contain the current configuration of this service. </p>
<p><strong>Return Values</strong></p>
<p>TRUE If the function succeeds otherwise FALSE. To get extended error information, 
call GetLastError. </p>
<p><strong>Remarks</strong></p>
<p>Queries this service for its current configuration. Bear in mind that since the 
QUERY_SERVICE_CONFIG is a variable sized structure, internally this function will 
allocate the required memory for lpServiceConfig, It is the responsibility of the 
client to delete this structure. This can be done as follows:</p>
<p>LPQUERY_SERVICE_CONFIG lpConfig = NULL;<br>service.QueryConfig(lpConfig);<br>
delete [] reinterpret_cast&lt;BYTE*&gt;(lpConfig);</p>
<p>&nbsp;</p>
<p><a name="scmsCreate"></a><strong>CNTScmService::Create</strong></p>
<p><strong>BOOL Create(CNTServiceControlManager&amp; </strong><em>Manager</em><strong>, 
LPCTSTR </strong><em>lpServiceName</em><strong>, LPCTSTR </strong><em>lpDisplayName</em><strong>, 
DWORD </strong><em>dwDesiredAccess</em><strong>, DWORD </strong><em>dwServiceType</em><strong>, 
DWORD </strong><em>dwStartType</em><strong>, DWORD </strong><em>dwErrorControl</em><strong>, 
LPCTSTR </strong><em>lpBinaryPathName</em><strong>, LPCTSTR </strong><em>lpLoadOrderGroup</em><strong>, 
LPDWORD </strong><em>lpdwTagId</em><strong>, LPCTSTR </strong><em>lpDependencies</em><strong>, 
LPCTSTR </strong><em>lpServiceStartName</em><strong>, LPCTSTR </strong><em>lpPassword</em><strong>);</strong></p>
<p><strong>Remarks</strong></p>
<p>This is a simple wrapper for the SDK call CreateService. See the SDK for full 
details on this function.</p>
<p>&nbsp;</p>
<p><a name="scmsDelete"></a><strong>CNTScmService::Delete</strong></p>
<p><strong>BOOL Delete() const;</strong></p>
<p><strong>Remarks</strong></p>
<p>This is a simple wrapper for the SDK call DeleteService. See the SDK for full 
details on this function.</p>
<p>&nbsp;</p>
<p><a name="scmsEnumDependents"></a><strong>CNTScmService::EnumDependents</strong></p>
<p><strong>BOOL EnumDependents(DWORD </strong><em>dwServiceState</em><strong>, DWORD
</strong><em>dwUserData</em><strong>, ENUM_SERVICES_PROC </strong><em>lpEnumServicesFunc</em><strong>) 
const;</strong></p>
<p><strong>Parameters</strong></p>
<p><em>dwServiceState</em> Specifies the services to enumerate based on their running 
state. </p>
<p><em>dwUserData</em> Any user defined DWORD which you want to send to the callback 
function.</p>
<p><em>lpEnumServicesFunc</em> pointer to a callback function to use to enumerate 
the dependent services</p>
<p><strong>Remarks</strong></p>
<p>This function allows you to enumerate the services upon which this service is 
dependent. Internally this calls EnumDependentServices and calls the callback function 
for each service. The format of the callback function is:</p>
<p>BOOL CALLBACK ENUM_SERVICES_PROC(DWORD dwData, ENUM_SERVICE_STATUS&amp; ServiceStatus);</p>
<p><em>dwData</em> This is the value as send into the Enumeration function</p>
<p><em>ServiceStatus</em> Contains the information related to the enumerated service. 
See the SDK documentation for further details.</p>
<p>Return TRUE from the function to continue enumeration and FALSE to stop enumeration</p>
<p>&nbsp;</p>
<p><a name="scmsQueryObjectSecurity"></a><strong>CNTScmService::QueryObjectSecurity</strong></p>
<p><strong>BOOL QueryObjectSecurity(SECURITY_INFORMATION </strong><em>dwSecurityInformation</em><strong>, 
PSECURITY_DESCRIPTOR&amp; </strong><em>lpSecurityDescriptor</em><strong>) const;</strong></p>
<p><strong>Remarks</strong></p>
<p>This is a simple wrapper for the SDK call QueryServiceObjectSecurity. See the 
SDK for full details on this function.</p>
<p>&nbsp;</p>
<p><a name="scmsSetObjectSecurity"></a><strong>CNTScmService::SetObjectSecurity</strong></p>
<p><strong>BOOL SetObjectSecurity(SECURITY_INFORMATION </strong><em>dwSecurityInformation</em><strong>, 
PSECURITY_DESCRIPTOR&amp; </strong><em>lpSecurityDescriptor</em><strong>) const;</strong></p>
<p><strong>Remarks</strong></p>
<p>This is a simple wrapper for the SDK call SetServiceObjectSecurity. See the SDK 
for full details on this function. Bear in mind that since the PSECURITY_DESCRIPTOR 
is a variable sized structure, internally this function will allocate the required 
memory for lpSecurityDescriptor, It is the responsibility of the client to delete 
this structure. This can be done as follows:</p>
<p>PSECURITY_DESCRIPTOR lpDescriptor = NULL;<br>service.QueryObjectSecurity(whatever, 
lpDescriptor);<br>delete [] reinterpret_cast&lt;BYTE*&gt;(lpDescriptor);</p>
<p>&nbsp;</p>
<p><a name="ChangeDescription"></a><strong>CNTScmService::ChangeDescription</strong></p>
<p><strong>BOOL ChangeDescription(const CString&amp; </strong><i>sDescription</i><strong>);</strong></p>
<p><strong>Remarks</strong></p>
<p>This is a simple wrapper for the SDK call ChangeServiceConfig2 using the info 
level SERVICE_CONFIG_DESCRIPTION. See the SDK for full details on this function.</p>
<p>&nbsp;</p>
<p><a name="QueryDescription"></a><strong>CNTScmService::QueryDescription</strong></p>
<p><strong>BOOL QueryDescription(CString&amp; </strong><i>sDescription</i><strong>) 
const;</strong></p>
<p><strong>Remarks</strong></p>
<p>This is a simple wrapper for the SDK call QueryServiceConfig2 using the info 
level SERVICE_CONFIG_DESCRIPTION. See the SDK for full details on this function.</p>
<p>&nbsp;</p>
<p><a name="ChangeFailureActions"></a><strong>CNTScmService::ChangeFailureActions</strong></p>
<p><strong>BOOL ChangeFailureActions(LPSERVICE_FAILURE_ACTIONS* </strong><i>pFailureActions</i><strong>);</strong></p>
<p><strong>Remarks</strong></p>
<p>This is a simple wrapper for the SDK call ChangeServiceConfig2 using the info 
level SERVICE_CONFIG_FAILURE_ACTIONS. See the SDK for full details on this function.</p>
<p>&nbsp;</p>
<p><a name="QueryFailureActions"></a><strong>CNTScmService::QueryFailureActions</strong></p>
<p><b>BOOL QueryFailureActions(LPSERVICE_FAILURE_ACTIONS&amp; </b><i>lpActions</i><b>) 
const;</b></p>
<p><strong>Remarks</strong></p>
<p>This is a simple wrapper for the SDK call QueryServiceConfig2 using the info 
level SERVICE_CONFIG_FAILURE_ACTIONS. See the SDK for full details on this function. 
Bear in mind that since the SERVICE_FAILURE_ACTIONS is a variable sized structure, 
internally this function will allocate the required memory for lpActions, It is 
the responsibility of the client to delete this structure. This can be done as follows:</p>
<p>LPSERVICE_FAILURE_ACTIONS lpActions = NULL;<br>service.QueryFailureActions(lpActions);<br>
delete [] reinterpret_cast&lt;BYTE*&gt;(lpActions);</p>
<p>&nbsp;</p>
<p><strong><a name="ChangeDelayAutoStart"></a>CNTScmService::ChangeDelayAutoStart</strong></p>
<p><b>BOOL ChangeDelayAutoStart(BOOL </b><i>bDelayedAutoStart</i><b>) const;</b></p>
<p><strong>Remarks</strong></p>
<p>This is a simple wrapper for the SDK call ChangeServiceConfig2 using the info 
level SERVICE_CONFIG_DELAYED_AUTO_START_INFO. See the SDK for full details on this 
function. </p>
<p>&nbsp;</p>
<p><strong><a name="QueryDelayAutoStart"></a>CNTScmService::QueryDelayAutoStart</strong></p>
<p><b>BOOL QueryDelayAutoStart(BOOL&amp; </b><i>bDelayedAutoStart</i><b>) const;</b></p>
<p><strong>Remarks</strong></p>
<p>This is a simple wrapper for the SDK call QueryServiceConfig2 using the info 
level SERVICE_CONFIG_DELAYED_AUTO_START_INFO. See the SDK for full details on this 
function. </p>
<p>&nbsp;</p>
<p><strong><a name="ChangeFailureActionsFlag"></a>CNTScmService::ChangeFailureActionsFlag</strong></p>
<p><b>BOOL ChangeFailureActionsFlag(BOOL </b><i>bFailureActionsOnNonCrashFailure</i><b>) 
const;</b></p>
<p><strong>Remarks</strong></p>
<p>This is a simple wrapper for the SDK call ChangeServiceConfig2 using the info 
level SERVICE_CONFIG_FAILURE_ACTIONS_FLAG. See the SDK for full details on this 
function. </p>
<p>&nbsp;</p>
<p><strong><a name="QueryFailureActionsFlag"></a>CNTScmService::QueryFailureActionsFlag</strong></p>
<p><b>BOOL QueryFailureActionsFlag(BOOL&amp; </b><i>bFailureActionsOnNonCrashFailure</i><b>) 
const;</b></p>
<p><strong>Remarks</strong></p>
<p>This is a simple wrapper for the SDK call QueryServiceConfig2 using the info 
level SERVICE_CONFIG_FAILURE_ACTIONS_FLAG . See the SDK for full details on this 
function. </p>
<p>&nbsp;</p>
<p><strong><a name="ChangeSidType"></a>CNTScmService::ChangeSidType</strong></p>
<p><b>BOOL ChangeSidType(DWORD </b><i>dwServiceSidType</i><b>) const;</b></p>
<p><strong>Remarks</strong></p>
<p>This is a simple wrapper for the SDK call ChangeServiceConfig2 using the info 
level SERVICE_CONFIG_SERVICE_SID_INFO. See the SDK for full details on this function.
</p>
<p>&nbsp;</p>
<p><strong><a name="QuerySidType"></a>CNTScmService::QuerySidType</strong></p>
<p><b>BOOL QuerySidType(DWORD&amp; </b><i>dwServiceSidtype</i><b>) const;</b></p>
<p><strong>Remarks</strong></p>
<p>This is a simple wrapper for the SDK call QueryServiceConfig2 using the info 
level SERVICE_CONFIG_SERVICE_SID_INFO. See the SDK for full details on this function.
</p>
<p>&nbsp;</p>
<p><strong><a name="ChangeRequiredPrivileges"></a>CNTScmService::ChangeRequiredPrivileges</strong></p>
<p><b>BOOL ChangeRequiredPrivileges(const CStringArray&amp; </b><i>privileges</i><b>) 
const;</b></p>
<p><strong>Remarks</strong></p>
<p>This is a simple wrapper for the SDK call ChangeServiceConfig2 using the info 
level SERVICE_CONFIG_REQUIRED_PRIVILEGES_INFO. See the SDK for full details on this 
function. </p>
<p>&nbsp;</p>
<p><strong><a name="QueryRequiredPrivileges"></a>CNTScmService::QueryRequiredPrivileges</strong></p>
<p><b>BOOL QueryRequiredPrivileges(CStringArray&amp; </b><i>dwServiceSidtype</i><b>) 
const;</b></p>
<p><strong>Remarks</strong></p>
<p>This is a simple wrapper for the SDK call QueryServiceConfig2 using the info 
level SERVICE_CONFIG_REQUIRED_PRIVILEGES_INFO. See the SDK for full details on this 
function. </p>
<p>&nbsp;</p>
<p><strong><a name="ChangePreShutdown"></a>CNTScmService::ChangePreShutdown</strong></p>
<p><b>BOOL ChangePreShutdown(DWORD </b><i>dwPreShutdownTimeout</i><b>) const;</b></p>
<p><strong>Remarks</strong></p>
<p>This is a simple wrapper for the SDK call ChangeServiceConfig2 using the info 
level SERVICE_CONFIG_PRESHUTDOWN_INFO. See the SDK for full details on this function.
</p>
<p>&nbsp;</p>
<p><strong><a name="QueryPreShutdown"></a>CNTScmService::QueryPreShutdown</strong></p>
<p><b>BOOL QueryPreShutdown(DWORD&amp; </b><i>dwPreShutdownTimeout</i><b>) const;</b></p>
<p><strong>Remarks</strong></p>
<p>This is a simple wrapper for the SDK call QueryServiceConfig2 using the info 
level SERVICE_CONFIG_PRESHUTDOWN_INFO. See the SDK for full details on this function.
</p>
<p>&nbsp;</p>
<p><strong><a name="ChangeTrigger"></a>CNTScmService::ChangeTrigger</strong></p>
<p><strong>BOOL ChangeTrigger(PSERVICE_TRIGGER_INFO* </strong><i>pTriggerInfo</i><strong>);</strong></p>
<p><strong>Remarks</strong></p>
<p>This is a simple wrapper for the SDK call ChangeServiceConfig2 using the info 
level SERVICE_CONFIG_TRIGGER_INFO. See the SDK for full details on this function.</p>
<p>&nbsp;</p>
<p><strong><a name="QueryTrigger"></a>CNTScmService::QueryTrigger</strong></p>
<p><b>BOOL QueryTrigger(PSERVICE_TRIGGER_INFO&amp; </b><i>pTriggerInfo</i><b>) const;</b></p>
<p><strong>Remarks</strong></p>
<p>This is a simple wrapper for the SDK call QueryServiceConfig2 using the info 
level SERVICE_CONFIG_TRIGGER_INFO. See the SDK for full details on this function. 
Bear in mind that since the SERVICE_TRIGGER_INFO is a variable sized structure, 
internally this function will allocate the required memory for pTriggerInfo, It 
is the responsibility of the client to delete this structure. This can be done as 
follows:</p>
<p>PSERVICE_TRIGGER_INFO pTriggerInfo = NULL;<br>service.QueryTriggerlpTriggerInfoActions);<br>
delete [] reinterpret_cast&lt;BYTE*&gt;(pTriggerInfo);</p>
<p>&nbsp;</p>
<p><strong><a name="ChangePreferredNode"></a>CNTScmService::ChangePreferredNode</strong></p>
<p><b>BOOL ChangePreferredNode(USHORT </b><i>usPreferredNode, </i><b>BOOL </b>
<i>bDelete</i><b>) const;</b></p>
<p><strong>Remarks</strong></p>
<p>This is a simple wrapper for the SDK call ChangeServiceConfig2 using the info 
level SERVICE_CONFIG_PREFERRED_NODE. See the SDK for full details on this function.
</p>
<p>&nbsp;</p>
<p><strong><a name="QueryPreferredNode"></a>CNTScmService::QueryPreferredNode</strong></p>
<p><b>BOOL QueryPreShutdown(USHORT&amp; </b><i>usPrefrredNode, </i><strong>BOOL&amp;
</strong><i>bDelete</i><b>) const;</b></p>
<p><strong>Remarks</strong></p>
<p>This is a simple wrapper for the SDK call QueryServiceConfig2 using the info 
level SERVICE_CONFIG_PREFERRED_NODE. See the SDK for full details on this function.
</p>
<p>&nbsp;</p>
<p><strong><a name="NotifyStatusChange"></a>CNTScmService::NotifyStatusChange</strong></p>
<p><b>BOOL NotifyStatusChange(DWORD </b><i>udwNotifyMask, </i><strong>BPSERVICE_NOTIFY
</strong><i>pNotifyBuffer</i><b>) const;</b></p>
<p><strong>Remarks</strong></p>
<p>This is a simple wrapper for the SDK call NotifyServiceStatusChange. See the 
SDK for full details on this function. </p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><a name="sumCNTServiceControlManager"></a><strong>CNTServiceControlManager</strong></p>
<p>CNTServiceControlManager is a class which encapsulates a connection to a Service 
Control Manager (SCM) on some machine. Functionality provided includes enumeration, 
database locking and service access.</p>
<p>&nbsp;</p>
<p><strong>Functions this class provides include:</strong></p>
<p><b><a href="#CNTServiceControlManager">CNTServiceControlManager<br></a>
<a href="#~CNTServiceControlManager">~CNTServiceControlManager<br></a>
<a href="#scmHandle">operator HANDLE<br></a><a href="#scmAttach">Attach<br></a>
<a href="#scmDetach">Detach<br></a><a href="#scmOpen">Open<br></a>
<a href="#scmClose">Close<br></a><a href="#scmQueryLockStatus">QueryLockStatus<br>
</a><a href="#scmEnumServices">EnumServices<br></a><a href="#scmOpenService">OpenService<br>
</a><a href="#scmLock">Lock<br></a><a href="#scmUnlock">Unlock</a></b></p>
<p>&nbsp;</p>
<p><a name="CNTServiceControlManager"></a><strong>CNTServiceControlManager::CNTServiceControlManager</strong></p>
<p><strong>CNTServiceControlManager();</strong></p>
<p><strong>Remarks</strong></p>
<p>This is the default constructor which just initializes all internal variables 
to a safe state.</p>
<p><strong>See Also </strong><br><a href="#~CNTServiceControlManager">~CNTServiceControlManager</a></p>
<p>&nbsp;</p>
<p><a name="~CNTServiceControlManager"></a><strong>CNTServiceControlManager::~CNTServiceControlManager</strong></p>
<p><strong>~CNTServiceControlManager();</strong></p>
<p><strong>Remarks</strong></p>
<p>This is the standard destructor for the class. Internally it will call
<a href="#scmClose">Close</a> to ensure that any handle that is opened by this instance 
is closed</p>
<p><strong>See Also <br></strong><a href="#scmClose">Close</a></p>
<p>&nbsp;</p>
<p><a name="scmHandle"></a><strong>CNTServiceControlManager::operator HANDLE</strong></p>
<p><strong>operator SC_HANDLE() const;</strong></p>
<p><strong>Return Value:</strong></p>
<p>The underlying SDK service handle representing this class.</p>
<p><strong>Remarks</strong></p>
<p>This function exposes the underlying handle which the CNTServiceControlManager 
class wraps. This function is provided for integration with legacy code which uses 
the handle directly.</p>
<p>&nbsp;</p>
<p><a name="scmAttach"></a><strong>CNTServiceControlManager::Attach</strong></p>
<p><strong>BOOL Attach(SC_HANDLE </strong><em>hSCM</em><strong>);</strong></p>
<p><strong>Return Value</strong></p>
<p>TRUE if the function was successful, otherwise FALSE. To get extended error information, 
call GetLastError </p>
<p><strong>Parameters</strong></p>
<p><em>hSCM</em> An SDK service control manager handle returned from SDK calls to 
the SCM APIs</p>
<p><strong>Remarks</strong></p>
<p>Use this member function to attach an existing SDK handle to a CNTServiceControlManager.</p>
<p><strong>See Also</strong> <br><a href="#scmDetach">Detach</a></p>
<p>&nbsp;</p>
<p><a name="scmDetach"></a><strong>CNTServiceControlManager::Detach</strong></p>
<p><strong>SC_HANDLE Detach();</strong></p>
<p><strong>Return Value</strong></p>
<p>The SDK service control manager handle</p>
<p><strong>Remarks</strong></p>
<p>Call this function to detach m_hSCM from the CNTServiceControlManager object 
and&nbsp; set m_hSCM to NULL.</p>
<p><strong>See Also</strong> <br><a href="#scmAttach">Attach</a></p>
<p>&nbsp;</p>
<p><a name="scmOpen"></a><strong>CNTServiceControlManager::Open</strong></p>
<p><strong>BOOL Open(LPCTSTR </strong><em>pszMachineName</em><strong>, DWORD
</strong><em>dwDesiredAccess</em><strong>);</strong></p>
<p><strong>Remarks</strong></p>
<p>This is a simple wrapper for the SDK call OpenSCManager. See the SDK for full 
details on this function.</p>
<p>&nbsp;</p>
<p><a name="scmClose"></a><strong>CNTServiceControlManager::Close</strong></p>
<p><strong>void Close();</strong></p>
<p><strong>Remarks</strong></p>
<p>This frees the SC_HANDLE by internally calling CloseServiceHandle which this 
class encapsulates.</p>
<p>&nbsp;</p>
<p><a name="scmQueryLockStatus"></a><strong>CNTServiceControlManager::QueryLockStatus</strong></p>
<p><strong>BOOL QueryLockStatus(LPQUERY_SERVICE_LOCK_STATUS&amp; </strong><em>lpLockStatus</em><strong>) 
const;</strong></p>
<p><strong>Remarks</strong></p>
<p>This is a simple wrapper for the SDK call QueryServiceLockStatus. See the SDK 
for full details on this function. Bear in mind that since the LPQUERY_SERVICE_LOCK_STATUS 
is a variable sized structure, internally this function will allocate the required 
memory for lpLockStatus, It is the responsibility of the client to delete this structure. 
This can be done as follows:</p>
<p>LPQUERY_SERVICE_LOCK_STATUS lpLockStatus = NULL;<br>scm.QueryLockStatus(lpLockStatus);<br>
delete [] reinterpret_cast&lt;BYTE*&gt;(lpLockStatus);</p>
<p>&nbsp;</p>
<p><a name="scmEnumServices"></a><strong>CNTServiceControlManager::EnumServices</strong></p>
<p><strong>BOOL EnumServices(DWORD </strong><em>dwServiceType</em><strong>, DWORD
</strong><em>dwServiceState</em><strong>, void* </strong><em>pUserData</em><strong>, 
ENUM_SERVICES_PROC </strong><em>lpEnumServicesFunc</em><strong>) const;</strong></p>
<p><b>BOOL EnumServices(DWORD </b><i>dwServiceType</i><b>, DWORD </b><i>dwServiceState</i><b>, 
LPCTSTR </b><i>pszGroupName</i><b>, void* </b><i>pUserData</i><b>, ENUM_SERVICES_PROC2
</b><i>lpEnumServicesFunc</i><b>) const;</b></p>
<p><strong>Parameters</strong></p>
<p><i>dwServiceType</i> Specifies the type of services to enumerate. </p>
<p><i>dwServiceState</i> Specifies the services to enumerate based on their running 
state. </p>
<p><em>pUserData</em> Any user defined void* which you want to send to the callback 
function.</p>
<p><i>pszGroupName</i> Specifies a load-order group name. If this parameter is a 
string, the only services enumerated are those that belong to the group that has 
the name specified by the string. If this parameter is an empty string, only services 
that do not belong to any group are enumerated. If this parameter is NULL, group 
membership is ignored and all services are enumerated.</p>
<p><em>lpEnumServicesFunc</em> pointer to a callback function to use to enumerate 
the dependent services</p>
<p><strong>Remarks</strong></p>
<p>This function allows you to enumerate the services which in the SCM. Internally 
this calls EnumServicesStatus or (EnumServicesStatusEx) and calls the callback function 
for each service. The format of the callback functions are:</p>
<p>typedef BOOL CALLBACK ENUM_SERVICES_PROC(void* pData, ENUM_SERVICE_STATUS&amp; ServiceStatus);</p>
<p>typedef BOOL CALLBACK ENUM_SERVICES_PROC2(void* pData, ENUM_SERVICE_STATUS_PROCESS&amp; 
ssp);</p>
<p><em>pData</em> This is the value as send into the enumeration function</p>
<p><em>ServiceStatus</em> Contains the information related to the enumerated service. 
See the SDK documentation for further details.</p>
<p><em>ssp</em> Contains the information related to the enumerated service. See 
the SDK documentation for further details.</p>
<p>Return TRUE from the function to continue enumeration and FALSE to stop enumeration</p>
<p>&nbsp;</p>
<p><a name="scmOpenService"></a><strong>CNTServiceControlManager::OpenService</strong></p>
<p><strong>BOOL OpenService(LPCTSTR </strong><em>lpServiceName</em><strong>, DWORD
</strong><em>dwDesiredAccess</em><strong>, CNTScmService&amp; </strong><em>service</em><strong>) 
const;</strong></p>
<p><strong>Remarks</strong></p>
<p>This is a simple wrapper for the SDK call of the same name. See the SDK for full 
details on this function.</p>
<p>&nbsp;</p>
<p><a name="scmLock"></a><strong>CNTServiceControlManager::Lock</strong></p>
<p><strong>BOOL Lock();</strong></p>
<p><strong>Remarks</strong></p>
<p>This is a simple wrapper for the SDK call LockServiceDatabase. See the SDK for 
full details on this function.</p>
<p>&nbsp;</p>
<p><a name="scmUnlock"></a><strong>CNTServiceControlManager::Unlock</strong></p>
<p><strong>BOOL Unlock();</strong></p>
<p><strong>Remarks</strong></p>
<p>This is a simple wrapper for the SDK call UnlockServiceDatabase. See the SDK 
for full details on this function.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><a name="sumCEventLogRecord"></a><strong>CEventLogRecord</strong></p>
<p>CEventLogRecord is a C++ wrapper class for the EVENTLOGRECORD structure as provided 
in the SDK. For anyone who has had to use this class using raw SDK calls, you will 
appreciate the easier access which the class provides.</p>
<p>&nbsp;</p>
<p><strong>Functions and members this class provides include:</strong></p>
<p><b><a href="#CEventLogRecord">CEventLogRecord<br></a><a href="#elr=">operator=<br>
</a><a href="#m_dwRecordNumber">m_dwRecordNumber<br></a>
<a href="#m_dwTimeGenerated">m_dwTimeGenerated<br></a>
<a href="#m_dwTimeWritten">m_dwTimeWritten<br></a><a href="#m_dwEventID">m_dwEventID<br>
</a><a href="#m_wEventTypes">m_wEventTypes<br></a><a href="#m_wEventCategory">m_wEventCategory<br>
</a><a href="#m_UserSID">m_UserSID<br></a><a href="#m_Strings">m_Strings<br></a>
<a href="#m_Data">m_Data<br></a><a href="#m_sSourceName">m_sSourceName<br></a>
<a href="#m_sComputerName">m_sComputerName</a></b></p>
<p>&nbsp;</p>
<p><a name="CEventLogRecord"></a><strong>CEventLogRecord::CEventLogRecord</strong></p>
<p><strong>CEventLogRecord();</strong></p>
<p><strong>CEventLogRecord(const CEventLogRecord&amp; </strong><em>record</em><strong>);</strong></p>
<p><strong>CEventLogRecord(const EVENTLOGRECORD* </strong><em>pRecord</em><strong>);</strong></p>
<p><strong>Parameters</strong></p>
<p>record An existing CEventLogRecord</p>
<p>pRecord An existing SDK EVENTLOGRECORD structure</p>
<p>&nbsp;</p>
<p><a name="elr="></a><strong>CEventLogRecord::operator=</strong></p>
<p><strong>CEventLogRecord&amp; operator=(const CEventLogRecord&amp; </strong><em>record</em><strong>);</strong></p>
<p><strong>Remarks</strong></p>
<p>The standard copy constructor</p>
<p>&nbsp;</p>
<p><a name="m_dwRecordNumber"></a><strong>CEventLogRecord::m_dwRecordNumber</strong></p>
<p><strong>DWORD m_dwRecordNumber;</strong></p>
<p><strong>Remarks</strong></p>
<p>Contains the record number for this event log entry </p>
<p>&nbsp;</p>
<p><a name="m_dwTimeGenerated"></a><strong>CEventLogRecord::m_dwTimeGenerated</strong></p>
<p><strong>DWORD m_dwTimeGenerated;</strong></p>
<p><strong>Remarks</strong></p>
<p>The number of seconds since 1/1/1970 UCT since this entry was submitted.</p>
<p>&nbsp;</p>
<p><a name="m_dwTimeWritten"></a><strong>CEventLogRecord::m_dwTimeWritten</strong></p>
<p><strong>DWORD m_TimeWritten;</strong></p>
<p><strong>Remarks</strong></p>
<p>The number of seconds since 1/1/1970 UCT since this entry was written to the 
event log.</p>
<p>&nbsp;</p>
<p><a name="m_dwEventID"></a><strong>CEventLogRecord::m_dwEventID</strong></p>
<p><strong>DWORD m_dwEventID;</strong></p>
<p><strong>Remarks</strong></p>
<p>Specifies the event. This is specific to the source that generated the event 
log entry, and is used, together with <b>SourceName</b>, to identify a message in 
a message file that is presented to the user while viewing the log.</p>
<p>&nbsp;</p>
<p><a name="m_wEventTypes"></a><strong>CEventLogRecord::m_wEventTypes</strong></p>
<p><strong>WORD m_wEventType;</strong></p>
<p><strong>Remarks</strong></p>
<p>Specifies the type of event. </p>
<p>&nbsp;</p>
<p><a name="m_wEventCategory"></a><strong>CEventLogRecord::m_wEventCategory</strong></p>
<p><strong>WORD m_wEventCategory;</strong></p>
<p><strong>Remarks</strong></p>
<p>Specifies a subcategory for this event. This subcategory is source specific.
</p>
<p>&nbsp;</p>
<p><a name="m_UserSID"></a><strong>CEventLogRecord::m_UserSID</strong></p>
<p><strong>CByteArray m_UserSID;</strong></p>
<p><strong>Remarks</strong></p>
<p>A CByteArray representation of the security identifier of the active user at 
the time this event was logged. </p>
<p>&nbsp;</p>
<p><a name="m_Strings"></a><strong>CEventLogRecord::m_Strings</strong></p>
<p><strong>CStringArray m_Strings;</strong></p>
<p><strong>Remarks</strong></p>
<p>A CStringArray representation of the strings which are merged into the message 
before it is displayed to the user. </p>
<p>&nbsp;</p>
<p><a name="m_Data"></a><strong>CEventLogRecord::m_Data</strong></p>
<p><strong>CByteArray m_Data;</strong></p>
<p><strong>Remarks</strong></p>
<p>A CByteArray representation of the event-specific information within this event 
record.</p>
<p>&nbsp;</p>
<p><a name="m_sSourceName"></a><strong>CEventLogRecord::m_sSourceName</strong></p>
<p><strong>CString m_sSourceName;</strong></p>
<p><strong>Remarks</strong></p>
<p>Contains the string specifying the name of the source (application, service, 
driver, subsystem) that generated the entry.</p>
<p>&nbsp;</p>
<p><a name="m_sComputerName"></a><strong>CEventLogRecord::m_sComputerName</strong></p>
<p><strong>CString m_sComputerName;</strong></p>
<p><strong>Remarks</strong></p>
<p>Contains the string specifying the name of the computer that generated this event.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><a name="sumCNTEventLog"></a><strong>CNTEventLog</strong></p>
<p>CNTEventLog is a C++ wrapper class for accessing the NT Event Logs. You can consider 
this as the client side to the Event Log APIs.</p>
<p>&nbsp;</p>
<p><strong>Functions this class provides include:</strong></p>
<p><b><a href="#CNTEventLog">CNTEventLog<br></a><a href="#~CNTEventLog">~CNTEventLog<br>
</a><a href="#elHandle">operator HANDLE<br></a><a href="#elAttach">Attach<br>
</a><a href="#elDetach">Detach<br></a><a href="#elOpen">Open<br></a>
<a href="#elOpenBackup">OpenBackup<br></a><a href="#elOpenApplication">OpenApplication<br>
</a><a href="#elOpenSystem">OpenSystem<br></a><a href="#elOpenSecurity">OpenSecurity<br>
</a><a href="#elClose">Close<br></a><a href="#elBackup">Backup<br></a>
<a href="#elClear">Clear<br></a><a href="#elGetNumberOfRecords">GetNumberOfRecords<br>
</a><a href="#elGetOldestRecord">GetOldestRecord<br></a>
<a href="#elNotifyChange">NotifyChange<br></a><a href="#elReadNext">ReadNext<br>
</a><a href="#elReadPrev">ReadPrev</a></b><br><strong>
<a href="#GetFullInformation">GetFullInformation</a></strong></p>
<p>&nbsp;</p>
<p><a name="CNTEventLog"></a><strong>CNTEventLog::CNTEventLog</strong></p>
<p><strong>CNTEventLog();</strong></p>
<p><strong>Remarks</strong></p>
<p>This is the default constructor which just initializes all internal variables 
to a safe state.</p>
<p><strong>See Also <br></strong><a href="#~CNTEventLog">~CNTEventLog</a></p>
<p>&nbsp;</p>
<p><a name="~CNTEventLog"></a><strong>CNTEventLog::~CEventLog</strong></p>
<p><strong>~CNTEventLog();</strong></p>
<p><strong>Remarks</strong></p>
<p>This is the standard destructor for the class. Internally it will call
<a href="#elClose">Close</a> to ensure that any handle that is opened by this instance 
is closed</p>
<p><strong>See Also </strong><br><a href="#elClose">Close</a></p>
<p>&nbsp;</p>
<p><a name="elHandle"></a><strong>CNTEventLog::operator HANDLE</strong></p>
<p><strong>operator HANDLE() const;</strong></p>
<p><strong>Return Value:</strong></p>
<p>The underlying SDK event log handle representing this class.</p>
<p><strong>Remarks</strong></p>
<p>This function exposes the underlying handle which CNTEventLog class wraps. This 
function is provided for integration with legacy code which uses the handle directly.</p>
<p>&nbsp;</p>
<p><a name="elAttach"></a><strong>CNTEventLog::Attach</strong></p>
<p><strong>BOOL Attach(HANDLE </strong><em>hEventLog</em><strong>);</strong></p>
<p><strong>Return Value</strong></p>
<p>TRUE if the function was successful, otherwise FALSE. To get extended error information, 
call GetLastError </p>
<p><strong>Parameters</strong></p>
<p><em>hEventLog</em> An SDK event log handle returned from SDK calls to the Event 
log APIs</p>
<p><strong>Remarks</strong></p>
<p>Use this member function to attach an existing SDK handle to a CNTEventLog.</p>
<p><strong>See Also</strong> <br><a href="#elDetach">Detach</a></p>
<p>&nbsp;</p>
<p><a name="elDetach"></a><strong>CNTEventLog::Detach</strong></p>
<p><strong>HANDLE Detach();</strong></p>
<p><strong>Return Value</strong></p>
<p>The SDK event log handle</p>
<p><strong>Remarks</strong></p>
<p>Call this function to detach m_hEventLog from the CNTEventLog object and&nbsp; 
set m_hEventLog to NULL.</p>
<p><strong>See Also</strong> <br><a href="#elAttach">Attach</a></p>
<p>&nbsp;</p>
<p><a name="elOpen"></a><strong>CNTEventLog::Open</strong></p>
<p><strong>BOOL Open(LPCTSTR </strong><em>lpUNCServerName</em><strong>, LPCTSTR
</strong><em>lpSourceName</em><strong>);</strong></p>
<p><strong>Remarks</strong></p>
<p>This is a simple wrapper for the SDK call OpenEventLog. See the SDK for full 
details on this function.</p>
<p>&nbsp;</p>
<p><a name="elOpenBackup"></a><strong>CNTEventLog::OpenBackup</strong></p>
<p><strong>BOOL OpenBackup(LPCTSTR </strong><em>lpUNCServerName</em><strong>, LPCTSTR
</strong><em>lpFileName</em><strong>);</strong></p>
<p><strong>Remarks</strong></p>
<p>This is a simple wrapper for the SDK call OpenBackupEventLog. See the SDK for 
full details on this function.</p>
<p>&nbsp;</p>
<p><a name="elOpenApplication"></a><strong>CNTEventLog::OpenApplication</strong></p>
<p><strong>BOOL OpenApplication(LPCTSTR </strong><em>lpUNCServerName</em><strong>);</strong></p>
<p><strong>Remarks</strong></p>
<p>This is a sample wrapper for opening the &quot;Application&quot; event log on the specified 
computer, Internally it just calls <a href="#elOpen">Open</a> with the appropriate 
string &quot;Application&quot;.</p>
<p>&nbsp;</p>
<p><a name="elOpenSystem"></a><strong>CNTEventLog::OpenSystem</strong></p>
<p><strong>BOOL OpenSystem(LPCTSTR </strong><em>lpUNCServerName</em><strong>);</strong></p>
<p><strong>Remarks</strong></p>
<p>This is a sample wrapper for opening the &quot;system&quot; event log on the specified 
computer, Internally it just calls <a href="#elOpen">Open</a> with the appropriate 
string &quot;System&quot;.</p>
<p>&nbsp;</p>
<p><a name="elOpenSecurity"></a><strong>CNTEventLog::OpenSecurity</strong></p>
<p><strong>BOOL OpenSecurity(LPCTSTR </strong><em>lpUNCServerName</em><strong>);</strong></p>
<p><strong>Remarks</strong></p>
<p>This is a sample wrapper for opening the &quot;Security&quot; event log on the specified 
computer, Internally it just calls <a href="#elOpen">Open</a> with the appropriate 
string &quot;Security&quot;.</p>
<p>&nbsp;</p>
<p><a name="elClose"></a><strong>CNTEventLog::Close</strong></p>
<p><strong>BOOL Close();</strong></p>
<p><strong>Remarks</strong></p>
<p>This frees the HANDLE by internally calling CloseEventLog which this class encapsulates.</p>
<p>&nbsp;</p>
<p><a name="elBackup"></a><strong>CNTEventLog::Backup</strong></p>
<p><strong>BOOL Backup(LPCTSTR </strong><em>lpBackupFileName</em><strong>) const;</strong></p>
<p><strong>Remarks</strong></p>
<p>This is a simple wrapper for the SDK call BackupeventLog. See the SDK for full 
details on this function.</p>
<p>&nbsp;</p>
<p><a name="elClear"></a><strong>CNTEventLog::Clear</strong></p>
<p><strong>BOOL Clear(LPCTSTR </strong><em>lpBackupFileName</em><strong>) const;</strong></p>
<p><strong>Remarks</strong></p>
<p>This is a simple wrapper for the SDK call ClearEventLog. See the SDK for full 
details on this function.</p>
<p>&nbsp;</p>
<p><a name="elGetNumberOfRecords"></a><strong>CNTEventLog::GetNumberOfRecords</strong></p>
<p><strong>BOOL GetNumberOfRecords(DWORD&amp; </strong><em>dwNumberOfRecords</em><strong>) 
const;</strong></p>
<p><strong>Return Value</strong></p>
<p>TRUE if the function was successful, otherwise FALSE. To get extended error information, 
call GetLastError </p>
<p><strong>Parameters</strong></p>
<p><em>dwNumberOfRecords</em> Upon successful return this will contain the number 
of records in the event log.</p>
<p><strong>Remarks</strong></p>
<p>This is a simple wrapper for the SDK call GetNumberOfEventLogRecords. See the 
SDK for full details on this function.</p>
<p>&nbsp;</p>
<p><a name="elGetOldestRecord"></a><strong>CNTEventLog::GetOldestRecord</strong></p>
<p><strong>BOOL GetOldestRecord(DWORD&amp; </strong><em>dwOldestRecord</em><strong>) 
const;</strong></p>
<p><strong>Return Value</strong></p>
<p>TRUE if the function was successful, otherwise FALSE. To get extended error information, 
call GetLastError </p>
<p><strong>Parameters</strong></p>
<p><em>dwOldestRecord</em> Upon successful return this will contain the record number 
of the oldest record in the event log.</p>
<p><strong>Remarks</strong></p>
<p>This is a simple wrapper for the SDK call GetOldestEventLogRecord. See the SDK 
for full details on this function.</p>
<p>&nbsp;</p>
<p><a name="elNotifyChange"></a><strong>CNTEventLog::NotifyChange</strong></p>
<p><strong>BOOL NotifyChange(HANDLE </strong><em>hEvent</em><strong>) const;</strong></p>
<p><strong>Remarks</strong></p>
<p>This is a simple wrapper for the SDK call NotifyChangeEventLog. See the SDK for 
full details on this function.</p>
<p>&nbsp;</p>
<p><a name="elReadNext"></a><strong>CNTEventLog::ReadNext</strong></p>
<p><strong>BOOL ReadNext(CEventLogRecord&amp; </strong><em>record</em><strong>) const;</strong></p>
<p><strong>Return Value</strong></p>
<p>TRUE if the function was successful, otherwise FALSE. To get extended error information, 
call GetLastError </p>
<p><strong>Parameters</strong></p>
<p><em>record</em> Upon successful return this will contain the next record in the 
event log</p>
<p><strong>Remarks</strong></p>
<p>Reads the next record in forward chronological order from the event log. When 
this function returns successfully, the read position is incremented by one ready 
for the next read to occur.</p>
<p>&nbsp;</p>
<p><a name="elReadPrev"></a><strong>CNTEventLog::ReadPrev</strong></p>
<p><strong>BOOL ReadPrev(CEventLogRecord&amp; </strong><em>record</em><strong>) const;</strong></p>
<p><strong>Return Value</strong></p>
<p>TRUE if the function was successful, otherwise FALSE. To get extended error information, 
call GetLastError </p>
<p><strong>Parameters</strong></p>
<p><em>record</em> Upon successful return this will contain the previous record 
in the event log</p>
<p><strong>Remarks</strong></p>
<p>Reads the next record in reverse chronological order from the event log. When 
this function returns successfully, the read position is decremented by one ready 
for the next read to occur.</p>
<p>&nbsp;</p>
<p><strong><a name="GetFullInformation"></a>CNTEventLog::GetFullInformation</strong></p>
<p><strong>BOOL GetFullInformation(DWORD&amp; </strong><em>dwFull</em><strong>) const;</strong></p>
<p><strong>Return Value</strong></p>
<p>TRUE if the function was successful, otherwise FALSE. To get extended error information, 
call GetLastError </p>
<p><strong>Parameters</strong></p>
<p><em>dwFull</em> Indicates whether the event log is full. If the log is full, 
this member is TRUE. Otherwise, it is FALSE. </p>
<p><strong>Remarks</strong></p>
<p>This is a simple wrapper for the SDK call GetEventLogInformation using the InfoLevel 
of EVENTLOG_FULL_INFO. See the SDK for full details on this function.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><a name="Enhancements"></a>Planned Enhancements</h2>
<ul>
	<li>If you have any suggested improvements, please let me know so that I can 
	incorporate them into the next release.</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><a name="References"></a>References</h2>
<ul>
	<li>&quot;Creating a Simple Windows NT Service in C++&quot; by Nigel Thompson on the MSDN.</li>
	<li>The book &quot;Professional NT Services&quot; by Kevin Miller.</li>
	<li>
	<a href="http://ourworld.compuserve.com/homepages/Sam_Blackburn/wfc.htm">Win32 
	Foundation Classes </a>developed by Sam Blackburn</li>
	<li>For detailed information on how to integrate mc files into Visual Studio, 
	please see the CodeProject article
	<a href="http://www.codeproject.com/useritems/MCTutorial.asp">http://www.codeproject.com/useritems/MCTutorial.asp</a>.</li>
	<li>There are numerous articles in the Windows SDK which anyone contemplating 
	writing a service should read. Areas covered include: Writing to the NT Event 
	Log, Reading from the Event Log, How a simple C/SDK style service is structured, 
	the Service Control Manager (SCM), reporting your status back to the SCM, using 
	the message compiler (MC), debugging NT Services etc etc.</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><a name="Contact"></a>Contacting the Author</h2>
<p>PJ Naughter<br>Email: <a href="mailto:pjna@naughter.com">pjna@naughter.com</a><br>
Web: <a href="http://www.naughter.com">http://www.naughter.com</a><br>1 January 
2014</p>

</body>

</html>
